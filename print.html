<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rg3d Cheat Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="rg3d/introduction.html"><strong aria-hidden="true">2.</strong> rg3d</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/beginning/getting_started.html"><strong aria-hidden="true">2.1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/beginning/framework.html"><strong aria-hidden="true">2.1.1.</strong> Framework</a></li><li class="chapter-item expanded "><a href="rg3d/beginning/custom_game_loop.html"><strong aria-hidden="true">2.1.2.</strong> Custom game loop</a></li><li class="chapter-item expanded "><a href="rg3d/beginning/scene_and_scene_graph.html"><strong aria-hidden="true">2.1.3.</strong> Scene and scene graph</a></li><li class="chapter-item expanded "><a href="rg3d/beginning/data_management.html"><strong aria-hidden="true">2.1.4.</strong> Data management</a></li></ol></li><li class="chapter-item expanded "><a href="rg3d/animation/animation.html"><strong aria-hidden="true">2.2.</strong> Animation</a></li><li class="chapter-item expanded "><a href="rg3d/rendering/rendering.html"><strong aria-hidden="true">2.3.</strong> Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/rendering/shaders.html"><strong aria-hidden="true">2.3.1.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="rg3d/rendering/materials.html"><strong aria-hidden="true">2.3.2.</strong> Materials</a></li></ol></li><li class="chapter-item expanded "><a href="rg3d/sound/sound.html"><strong aria-hidden="true">2.4.</strong> Sound</a></li><li class="chapter-item expanded "><a href="rg3d/physics/physics.html"><strong aria-hidden="true">2.5.</strong> Physics</a></li><li class="chapter-item expanded "><a href="rg3d/ui/ui.html"><strong aria-hidden="true">2.6.</strong> User Interface</a></li><li class="chapter-item expanded "><a href="rg3d/resources/resources.html"><strong aria-hidden="true">2.7.</strong> Resource Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href=".rg3d/resources/sound.html"><strong aria-hidden="true">2.7.1.</strong> 3D Models</a></li><li class="chapter-item expanded "><a href=".rg3d/resources/texture.html"><strong aria-hidden="true">2.7.2.</strong> Textures</a></li><li class="chapter-item expanded "><a href=".rg3d/resources/sound.html"><strong aria-hidden="true">2.7.3.</strong> Sound Buffers</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="rusty-editor/introduction.html"><strong aria-hidden="true">3.</strong> rusty-editor</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rg3d Cheat Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rg3d-cheat-book"><a class="header" href="#rg3d-cheat-book">rg3d Cheat Book</a></h1>
<p>Practical reference and user guides for <a href="https://github.com/rg3dengine/rg3d">rg3d game engine</a> and
<a href="https://github.com/rg3dengine/rusty-editor">rusty-editor</a>.</p>
<p>The book is in early development stage, you can help to improve it by making a contribution in its
<a href="https://github.com/rg3d-book/rg3d-book.github.io">repository</a>. Don't be shy, every tip is helpful!</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>Despite the look of it, the engine is quite friendly to newcomers, especially with some good guides. This section
of the book will guide you the basics of the engine.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The engine offers special framework to start making games as quickly as possible. It cares about engine initialization,
handles window events, calls every required methods and so on. In other words it helps you to get started as quickly
as possible with a need to put dozens lines of code to just create a window with a game loop.</p>
<p>The simplest app could be created with this code:</p>
<pre><pre class="playground"><code class="language-rust">use rg3d::{
    engine::Engine,
    engine::framework::prelude::*,
};

struct Game { }

impl GameState for Game {
    fn init(_engine: &amp;mut Engine) -&gt; Self where Self: Sized {
        Self { }
    }
}

fn main() {
    Framework::&lt;Game&gt;::new()
        .unwrap()
        .title(&quot;Simple&quot;)
        .run();
}
</code></pre></pre>
<p>The &quot;work-horse&quot; here is the <code>GameState</code> trait, it offers some optional method that could be used depending on
your needs.</p>
<ul>
<li><code>fn init(engine: &amp;mut Engine) -&gt; Self where Self: Sized</code> - should create the instance of your game. It accepts the engine instance as the first argument
which gives you full access to the engine during the initialization.</li>
<li><code>fn on_tick(&amp;mut self, engine: &amp;mut Engine, dt: f32, control_flow: &amp;mut ControlFlow)</code> - the game loop, it will
be called at fixed 60 FPS rate allowing you to run your game logic. The method gives you full access to the engine
so you're able to work it freely. The <code>dt</code> argument returns the amount of seconds that passed from the previous
call. The last argument (<code>control_flow</code>) allowing you to change the execution flow, for example setting it to
<code>ControlFlow::Exit</code> will force the game to quit.</li>
<li><code>fn on_ui_message(&amp;mut self, engine: &amp;mut Engine, message: UiMessage)</code> - the main function that listens events
from the user interface and gives you the ability to react. You should handle your UI in here.</li>
<li><code>fn on_device_event(&amp;mut self, engine: &amp;mut Engine, device_id: DeviceId, event: DeviceEvent)</code> - the function that
allows you to handle input from physical devices (mouse, keyboard, gamepads, etc.).</li>
<li><code>fn on_window_event(&amp;mut self, engine: &amp;mut Engine, event: WindowEvent)</code> - the function that allows you to do
something when the window of the game receives an event from operating system. The variety of events is large, and
everything depends on what you need. For example this method could be useful handle keyboard events.</li>
<li><code>fn on_exit(&amp;mut self, engine: &amp;mut Engine)</code> - the function that will be called right before your application
about to shut down allowing you to do some clean up or some other actions.</li>
</ul>
<p>As you can see it is very concise and simple, every method serves a particular purpose. </p>
<div style="break-before: page; page-break-before: always;"></div><p>(WIP)</p>
<p>The framework might be limiting for some cases, in such situations the engine could be initialized manually. It
requires some decent amount of code and could error-prone for beginners. You should use custom game loop only if
you're experienced game developer!</p>
<div style="break-before: page; page-break-before: always;"></div><p>When you're playing a game, you often see various objects scattered around on screen, all of them forming a
<em>scene</em>. Scene is just a set of various objects, as in many other game engines, rg3d allows you to create multiple
scenes for various purposes. For example, one scene could be used for menu, a bunch could be used for game levels,
and one for ending screen. Scenes also could be used to create a source of data for other scenes, such scenes called
<em>prefabs</em>. A scene could also be rendered in a texture, and the texture can be used in other scene - this way you
can create interactive screens that showing some other places.</p>
<p>While playing games, you could've noticed that some objects behaves like they're linked to other objects, for example
your character in a role-playing game could carry a sword. While the character holds the sword, it is linked to his
arm. Such relations between the objects could be presented by a graph structure.</p>
<p>Simply speaking, graph is a set of objects with hierarchical relationships between each object. Each object in the
graph is called <em>node</em>. In the example with the sword and the character, the sword is a <em>child</em> node of a character,
which in its turn is a <em>parent</em> node of a character. (Here we intentionally omit the fact that usually character
model contains complex skeleton with multiple bones and the sword is actually attached to one of hand's bones.)</p>
<h2 id="building-blocks-or-scene-nodes"><a class="header" href="#building-blocks-or-scene-nodes">Building blocks or scene nodes</a></h2>
<p>The engine offers various types of &quot;building blocks&quot; for your scene, each such block is called <em>scene node</em>.</p>
<ul>
<li><strong>Base</strong> - a node that stores hierarchical information (a handle to the parent node and a set of handles
to children nodes), local and global transform, name, tag, lifetime, etc. It has self-describing name - it
is used as a base node for every other scene node (via composition).</li>
<li><strong>Mesh</strong> - a node that represents a 3D model. This one of the most commonly used nodes in almost every game.
Meshes could be easily created either programmatically, or be made in some 3D modelling software (like Blender)
and loaded in your scene.</li>
<li><strong>Light</strong> - a node that represents a light source. There are three types of light sources:
<ul>
<li><strong>Directional</strong> - a light source that does not have position, only direction. The closest real-world example
is our Sun.</li>
<li><strong>Point</strong> - a light source that emits light in every direction. Real-world example: light bulb.</li>
<li><strong>Spot</strong> - a light source that emits light in a particular direction with a cone-like shape. Real-world example:
flashlight.</li>
</ul>
</li>
<li><strong>Camera</strong> - a node that allows you to see the world. You must have at least one camera in your scene to be
able to see anything.</li>
<li><strong>Sprite</strong> - a node that represents a quad that always faced towards a camera. It can have a texture, size, it
also can be rotated around the &quot;look&quot; axis.</li>
<li><strong>Particle system</strong> - a node that allows you to build visual effects using a huge set of small particles, it
can be used to create smoke, sparks, blood splatters, etc. effects.</li>
<li><strong>Terrain</strong> - a node that allows you to create complex landscapes with minimal effort.</li>
<li><strong>Decal</strong> - a node that paints on other nodes using a texture. It is used to simulate cracks in concrete walls,
damaged parts of the road, blood splatters, bullet holes, etc.</li>
</ul>
<p>These scene nodes allow you to build almost any kind of game.</p>
<h2 id="local-and-global-coordinates"><a class="header" href="#local-and-global-coordinates">Local and global coordinates</a></h2>
<p>Graph describes your scene in a very natural way, allowing you think in terms of relative and absolute coordinates
when working with <em>scene nodes</em>.</p>
<p>Scene node has two kinds of transform - local and global. Local transform defines where the node is located
(translation) relative to origin, how much it is scaled (in percent) and rotated (around any arbitrary axis).
Global transform is almost the same, but it also includes the whole chain of transforms of parent nodes. In the
previous example with the character, the sword has its own local transform which tells how much it should be
moved from origin to be exactly on a hand of the character. But global transform of the swords includes transform
of the entire character. So if you move the character, the local transform of the sword will remain the same, but
global transform will include the transform of the character.</p>
<p>This mechanism is very simple, yet powerful. The full grace of it unfolds when you're working with 3D models with
skeleton, each bone in the skeleton has its parent and a set of children. You can rotate/translate/scale bones to
animate your character.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The engine uses generation arenas (pools in engine's terminology) for efficient data management. Pool is a
vector with entries that can be either vacant or occupied. Each entry, no matter occupied it or vacant, also
stores a special number called <em>generation</em>. The generation number is used to understand whether an entry has
been changed over time or not. When an entry is reused, its generation number is increased leaving all previously
created handle leading to the entry invalid. This is a very simple and efficient algorithm for tracking the
&quot;lifetime&quot; of the objects.</p>
<p>To access the data in entries, the engine uses <em>handles</em>. The handle is a pair of index of an entry and a
<em>generation</em> number. When you put an object in the pool, it gives you the handle that &quot;leads&quot; to the object.
At this moment the generation of the handle matches the generation of the corresponding entry so the handle
is valid. It will remain valid util you &quot;free&quot; the object, which will make the entry vacant again.</p>
<p>Since the pool is just a contiguous memory block, it is much more CPU cache-friendly. This means that in most
cases the data portions will be loaded in CPU caches, making the access to the data blazing fast.</p>
<p>Almost every entity in the engine &quot;lives&quot; in its own pool, this make it easy to create such data structures
like graphs, where a node refers to other nodes. In this case scene nodes stores just handles (which is just
8 bytes of memory) to other nodes.</p>
<div style="break-before: page; page-break-before: always;"></div><p>(WIP)</p>
<div style="break-before: page; page-break-before: always;"></div><p>(WIP)</p>
<div style="break-before: page; page-break-before: always;"></div><p>Shader is a set of programs that runs directly on graphics adapter. Each program from the set is called
<em>sub-shader</em>. Sub-shaders linked with render pass, each render pass defines &quot;where&quot; to draw and an object.
&quot;where&quot; means that you can set up your own render pass and the renderer will use the sub-shader with 
your render pass. For the ease of use there are number of <a href="rg3d/rendering/shaders.html#predefined-render-passes">predefined render passes</a>.</p>
<p>Shaders have properties of various types that can be used together with materials to draw an object. </p>
<h2 id="shaders-language"><a class="header" href="#shaders-language">Shaders language</a></h2>
<p>The engine uses GLSL shading language for every sub-shader. There are numerous of GLSL guides over the 
internet, so there is no need to &quot;re-post&quot; the well documented info again.</p>
<p>There are very few differences:</p>
<ol>
<li>No need to define a version of the shader. Every shader source will be pre-processed, and it will 
get correct version automatically. Preprocessing is needed because the same shader could run on OpenGL
and WebGL (OpenGL ES) which have some differences.</li>
<li>There is a &quot;standard&quot; library of useful methods which is automatically included in every shader source
at preprocessing stage. The library source could be found
<a href="https://github.com/rg3dengine/rg3d/blob/master/src/renderer/framework/shaders/shared.glsl">here</a>. It 
is well documented, and you may find some functions useful for you job.</li>
</ol>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>Shader has rigid structure that could be described in this code snipped:</p>
<pre><code class="language-ron">(
    // A set of properties, there could be any amount of properties.
    properties: [
        (
            // Each property must have a name. This name must match with respective
            // uniforms! That's is the whole point of having properties.
            name: &quot;diffuseTexture&quot;,
            // Value has limited set of possible variants.
            value: Sampler(default: None, fallback: White)
        )
    ],
    // A set of render passes (see next section for more info)
    passes: [
        (
            // Name must match with the name of either standard render pass (see below) or
            // one of your passes.
            name: &quot;Forward&quot;,
            // A set of parameters that regulate renderer pipeline state.
            // This is mandatory field of each render pass.
            draw_parameters: DrawParameters(
                // A face to cull. Either Front or Back.
                cull_face: Some(Back),
                // Color mask. Defines which colors should be written to render target.
                color_write: ColorMask(
                    red: true,
                    green: true,
                    blue: true,
                    alpha: true,
                ),
                // Whether to modify depth buffer or not.
                depth_write: true,
                // Whether to use stencil test or not.
                stencil_test: None,
                // Whether to perform depth test when drawing.
                depth_test: true,
                // Blending options.
                blend: Some(BlendFunc(
                    sfactor: SrcAlpha,
                    dfactor: OneMinusSrcAlpha,
                )),
                // Stencil options.
                stencil_op: StencilOp(
                    fail: Keep,
                    zfail: Keep,
                    zpass: Keep,
                    write_mask: 0xFFFF_FFFF,
                ),
            ),
            // Vertex shader code.
            vertex_shader:
                r#&quot;
                layout(location = 0) in vec3 vertexPosition;
                layout(location = 1) in vec2 vertexTexCoord;
                uniform mat4 rg3d_worldViewProjection;
                out vec2 texCoord;
                void main()
                {
                    texCoord = vertexTexCoord;
                    gl_Position = rg3d_worldViewProjection * vertexPosition;
                }
                &quot;#;
            // Pixel shader code.
            pixel_shader:
                r#&quot;
                // Note that the name of this uniform match the name of the property up above.
                uniform sampler2D diffuseTexture;
                out vec4 FragColor;
                in vec2 texCoord;
                void main()
                {
                    FragColor = diffuseColor * texture(diffuseTexture, texCoord);
                }
                &quot;#;
        )
    ],
)
</code></pre>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p>Property is a named variable of some type. Properties directly tied with the uniforms in the sub-shaders,
for each you can have a property called <code>time</code>, and then you can define <code>uniform float time;</code> in your sub-shader
and the engine will pass property value to that uniform for you before drawing an object. Properties placed in 
a &quot;global namespace&quot;, which means that every sub-shader have &quot;access&quot; to the properties.</p>
<h2 id="built-in-properties"><a class="header" href="#built-in-properties">Built-in properties</a></h2>
<p>There are number of built-in properties, the full list is available
<a href="https://docs.rs/rg3d/0.23.1/rg3d/material/shader/struct.Shader.html#built-in-variables">here</a></p>
<h2 id="predefined-render-passes"><a class="header" href="#predefined-render-passes">Predefined render passes</a></h2>
<p>Predefined render passes helps you to create your own shader without a need to create your own render pass 
and to quickly start writing your shaders.</p>
<ul>
<li><strong>GBuffer</strong> - A pass that fills a set with render target sized textures with various data about each rendered 
object. These textures then are used for physically-based lighting. Use this pass when you want the standard 
lighting to work with your objects.</li>
<li><strong>Forward</strong> - A pass that draws an object directly in render target. This pass is very limiting, it does not 
support lighting, shadows, etc. It should be only used to render translucent objects.</li>
<li><strong>SpotShadow</strong> - A pass that emits depth values for an object, later this depth map will be used to render shadows.</li>
<li><strong>PointShadow</strong> - A pass that emits distance from a fragment to a point light, later this depth map will be used
to render shadows.</li>
</ul>
<h2 id="drawing-parameters"><a class="header" href="#drawing-parameters">Drawing parameters</a></h2>
<p>Drawing parameters defines which GPU functions to use and at which state. For example, to render transparent
objects you need to enable blending with specific blending rules. Or you need to disable culling to draw objects
from both sides. This is when draw parameters comes in handy. There are relatively large list of drawing
parameters, and it could confuse a person who didn't get used to work with graphics. Thankfully there is a good
documentation about this available <a href="https://docs.rs/rg3d/0.23.1/rg3d/material/shader/struct.Shader.html#drawing-parameters">here</a></p>
<h2 id="vertex-shader"><a class="header" href="#vertex-shader">Vertex shader</a></h2>
<p>Vertex shader operates on single vertices, it must provide at least the position of the vertex
in clipping space. In other words it has to do at least this:</p>
<pre><code class="language-glsl">layout(location = 0) in vec3 vertexPosition;

uniform mat4 rg3d_worldViewProjection; // Note the built-in variable.

void main()
{
    gl_Position = rg3d_worldViewProjection * vertexPosition;
}
</code></pre>
<p>This is the simplest vertex shader, using vertex shaders you can create various graphical effects that affects
vertices.</p>
<h2 id="pixel-shader"><a class="header" href="#pixel-shader">Pixel Shader</a></h2>
<p>Pixel shader (or more precisely - fragment shader), operates on a small fragment of your render target. In general
pixels shaders just writes some color to a render target (or multiple targets) using some program.</p>
<pre><code class="language-glsl">out vec4 FragColor;

void main()
{
    FragColor = vec4(1, 0, 0, 1);
}
</code></pre>
<p>This is the simplest pixel shader, it just fills the render target with red color.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Material defines a set of values for a shader. Materials usually contains textures (diffuse, normal, height, emission,
etc. maps), numerical values (floats, integers), vectors, booleans, matrices and arrays of each type, except
textures. Each parameter can be changed in runtime giving you the ability to create animated materials. However,
in practice, most materials are static, this means that once it created, it won't be changed anymore.</p>
<p>Please keep in mind that the actual &quot;rules&quot; of drawing an entity are stored in the shader, 
<strong>material is only a storage</strong> for specific uses of the shader. </p>
<p>Multiple materials can share the same shader, for example standard shader covers 95% of most common use cases,
and it is shared across multiple materials. The only difference are property values, for example you can draw
multiple cubes using the same shader, but with different textures.</p>
<p>Material itself can be shared across multiple places as well as the shader. This gives you the ability to render
multiple objects with the same material efficiently.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>It is very important re-use materials as much as possible, because the amount of materials used per frame
significantly correlates with performance. The more unique materials you have per frame, the more work has
to be done by the renderer and video driver to render a frame and the more time the frame will require for
rendering, thus lowering your FPS.</p>
<h2 id="standard-material"><a class="header" href="#standard-material">Standard material</a></h2>
<p>The engine offers a standard PBR material, PBR stands for &quot;Physically-Based Rendering&quot; which gives you the quality
of shading which is very close to materials in real world (to some extent of course).</p>
<p>The standard material can cover 95% of use cases, and it is suitable for almost any kind of game, except maybe
some cartoon-ish or stylized games. </p>
<p>The standard material has quite a lot of properties that can be used to fully utilize the power of PBR rendering:</p>
<ul>
<li><strong>diffuseColor</strong> - an RGBA color that will be used as a base color for you object. <strong>Caveat:</strong> the opacity value
(alpha) will be used only with <code>Forward</code> render path! This means that you will need to switch render path on your
mesh (<a href="rg3d/rendering/materials.html#transparency">see below</a>)</li>
<li><strong>diffuseTexture</strong> - a 2D texture containing the unlit &quot;basic&quot; colors of your object, this is the most commonly
used texture. For example, you can assign a brick wall texture to this property and your object will look a brick
wall.</li>
<li><strong>normalTexture</strong> - a 2D texture containing per-pixel normal vectors. </li>
<li><strong>metallicTexture</strong> - a 2D texture containing per-pixel metallic factor, where 0 - dielectric, 1 - metal.
In simple words it defines will your object reflect (1.0) the environment or not (0.0). </li>
<li><strong>roughnessTexture</strong> - a 2D texture containing per-pixel roughness factor, where 0 - completely flat, 1 - 
very rough.</li>
<li><strong>heightTexture</strong> - a 2D texture containing per-pixel displacement value, it is used with parallax mapping to
crate an effect of volume on a flat surface.</li>
<li><strong>emissionTexture</strong> - a 2D texture containing per-pixel emission lighting. You could use this to create emissive
surfaces like small lamps on wall of sci-fi ship, or to create glowing eyes for your monsters that will scare 
the player.</li>
<li><strong>lightmapTexture</strong> - a 2D texture containing per-pixel <strong>static</strong> lighting. It is used to apply precomputed
light to your 3D models, and the most common use case is to lit a static object using a static light. Precomputed
light is very cheap. The engine offers built-in lightmapper that can generated lightmaps for you.</li>
<li><strong>aoTexture</strong> - a 2D texture containing per-pixel shading values, allows you to &quot;bake&quot; shadows in for your 3D
object.</li>
<li><strong>texCoordScale</strong> - a 2D vector that allows you to scale texture coordinates used to sample the textures 
mentioned above (expect lightmaps, they're using separate texture coordinates)</li>
<li><strong>layerIndex</strong> - a natural number that is used for decals masking, a decal will only be applied to your mesh
iff the decal has matching index. </li>
<li><strong>emissionStrength</strong> - a 3D vector that allows you to set the strength of emission per-channel (R, G, B) for 
your <code>emissionTexture</code></li>
</ul>
<h2 id="transparency"><a class="header" href="#transparency">Transparency</a></h2>
<p>The standard material offers very basic transparency support, to use it you have to explicitly switch render
path on you mesh object. It could be done something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>graph[mesh_handle].as_mesh_mut().set_render_path(RenderPath::Forward);
<span class="boring">}
</span></code></pre></pre>
<p>After this your mesh will be rendered using specialized render pass called Forward which supports alpha-blending
and transparent objects. <strong>Caveat:</strong> Current forward renderer implementation does not support any kind of lighting,
if you need lighting, you will need to use custom shader for that!</p>
<h2 id="material-import"><a class="header" href="#material-import">Material import</a></h2>
<p>When you're loading a 3D model in the engine, the engine tries to convert the materials stored inside to standard
material. In most cases there is no way to create 100% matching material on the fly, instead the engine tries 
to its best to make sure the material will be imported as closely as possible to the original. Various 3D modelling
tools uses different material system, but all of them allowing you to export your 3D model in one of the commonly
used formats (such as FBX).</p>
<h3 id="blender"><a class="header" href="#blender">Blender</a></h3>
<p>When using Blender, make sure you using <strong>Principled BSDF</strong> material, it is the closest material that can be converted
to engine's standard material at almost 100% fidelity. </p>
<h3 id="3ds-max"><a class="header" href="#3ds-max">3Ds max</a></h3>
<p>It highly depends on the version of the 3Ds max, but in general the default material should work fine.</p>
<div style="break-before: page; page-break-before: always;"></div><p>(WIP)</p>
<div style="break-before: page; page-break-before: always;"></div><p>(WIP)</p>
<div style="break-before: page; page-break-before: always;"></div><p>(WIP)</p>
<div style="break-before: page; page-break-before: always;"></div><p>This chapter covers resource management in the engine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-buffers"><a class="header" href="#sound-buffers">Sound Buffers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="textures"><a class="header" href="#textures">Textures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-buffers-1"><a class="header" href="#sound-buffers-1">Sound Buffers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rusty-editor"><a class="header" href="#rusty-editor">rusty-editor</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
