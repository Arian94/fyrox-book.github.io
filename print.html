<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rg3d Cheat Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="rg3d/introduction.html"><strong aria-hidden="true">2.</strong> rg3d</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/beginning/getting_started.html"><strong aria-hidden="true">2.1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/beginning/framework.html"><strong aria-hidden="true">2.1.1.</strong> Framework</a></li><li class="chapter-item expanded "><a href="rg3d/beginning/custom_game_loop.html"><strong aria-hidden="true">2.1.2.</strong> Custom game loop</a></li><li class="chapter-item expanded "><a href="rg3d/beginning/scene_and_scene_graph.html"><strong aria-hidden="true">2.1.3.</strong> Scene and scene graph</a></li><li class="chapter-item expanded "><a href="rg3d/beginning/data_management.html"><strong aria-hidden="true">2.1.4.</strong> Data management</a></li></ol></li><li class="chapter-item expanded "><a href="rg3d/scene/scene.html"><strong aria-hidden="true">2.2.</strong> Scene</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/scene/graph.html"><strong aria-hidden="true">2.2.1.</strong> Graph</a></li><li class="chapter-item expanded "><a href="rg3d/scene/base_node.html"><strong aria-hidden="true">2.2.2.</strong> Base node</a></li><li class="chapter-item expanded "><a href="rg3d/scene/mesh_node.html"><strong aria-hidden="true">2.2.3.</strong> Mesh node</a></li><li class="chapter-item expanded "><a href="rg3d/scene/light_node.html"><strong aria-hidden="true">2.2.4.</strong> Light node</a></li><li class="chapter-item expanded "><a href="rg3d/scene/sprite_node.html"><strong aria-hidden="true">2.2.5.</strong> Sprite node</a></li><li class="chapter-item expanded "><a href="rg3d/scene/particle_system_node.html"><strong aria-hidden="true">2.2.6.</strong> Particle system node (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/scene/particle_system_node.html"><strong aria-hidden="true">2.2.7.</strong> Terrain node (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/scene/camera_node.html"><strong aria-hidden="true">2.2.8.</strong> Camera node (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/scene/decal_node.html"><strong aria-hidden="true">2.2.9.</strong> Decal node (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="rg3d/animation/animation.html"><strong aria-hidden="true">2.3.</strong> Animation (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/rendering/rendering.html"><strong aria-hidden="true">2.4.</strong> Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/rendering/shaders.html"><strong aria-hidden="true">2.4.1.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="rg3d/rendering/materials.html"><strong aria-hidden="true">2.4.2.</strong> Materials</a></li></ol></li><li class="chapter-item expanded "><a href="rg3d/sound/sound.html"><strong aria-hidden="true">2.5.</strong> Sound (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/physics/physics.html"><strong aria-hidden="true">2.6.</strong> Physics (WIP)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/physics/rigid_body.html"><strong aria-hidden="true">2.6.1.</strong> Rigid body (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/physics/collider.html"><strong aria-hidden="true">2.6.2.</strong> Collider (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/physics/joint.html"><strong aria-hidden="true">2.6.3.</strong> Joint (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="rg3d/ui/ui.html"><strong aria-hidden="true">2.7.</strong> User Interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/ui/basic_concepts/basic_concepts.html"><strong aria-hidden="true">2.7.1.</strong> Basic concepts</a></li><li class="chapter-item expanded "><a href="rg3d/ui/setting_up.html"><strong aria-hidden="true">2.7.2.</strong> Setting up a user interface</a></li><li class="chapter-item expanded "><a href="rg3d/ui/general_rules.html"><strong aria-hidden="true">2.7.3.</strong> General rules</a></li><li class="chapter-item expanded "><a href="rg3d/ui/font.html"><strong aria-hidden="true">2.7.4.</strong> Fonts (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/theme.html"><strong aria-hidden="true">2.7.5.</strong> Theme</a></li><li class="chapter-item expanded "><a href=".rg3d/ui/widgets.html"><strong aria-hidden="true">2.7.6.</strong> Widgets (WIP)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/ui/creating_button.html"><strong aria-hidden="true">2.7.6.1.</strong> Button (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/border.html"><strong aria-hidden="true">2.7.6.2.</strong> Border (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/canvas.html"><strong aria-hidden="true">2.7.6.3.</strong> Canvas (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/checkbox/check_box.html"><strong aria-hidden="true">2.7.6.4.</strong> Check box</a></li><li class="chapter-item expanded "><a href="rg3d/ui/curve_editor.html"><strong aria-hidden="true">2.7.6.5.</strong> Curve editor (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/decorator.html"><strong aria-hidden="true">2.7.6.6.</strong> Decorator (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/dock.html"><strong aria-hidden="true">2.7.6.7.</strong> Docking manager (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/dropdown_list.html"><strong aria-hidden="true">2.7.6.8.</strong> Dropdown list (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/expander.html"><strong aria-hidden="true">2.7.6.9.</strong> Expander (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/file_browser.html"><strong aria-hidden="true">2.7.6.10.</strong> File browser (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/grid.html"><strong aria-hidden="true">2.7.6.11.</strong> Grid (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/image.html"><strong aria-hidden="true">2.7.6.12.</strong> Image (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/inspector.html"><strong aria-hidden="true">2.7.6.13.</strong> Inspector (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/list_view.html"><strong aria-hidden="true">2.7.6.14.</strong> List view (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/menu.html"><strong aria-hidden="true">2.7.6.15.</strong> Menu (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/message_box.html"><strong aria-hidden="true">2.7.6.16.</strong> Message box (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/numeric.html"><strong aria-hidden="true">2.7.6.17.</strong> Numeric field (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/popup.html"><strong aria-hidden="true">2.7.6.18.</strong> Popup (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/progress_bar.html"><strong aria-hidden="true">2.7.6.19.</strong> Progress bar (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/range.html"><strong aria-hidden="true">2.7.6.20.</strong> Range (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/rect.html"><strong aria-hidden="true">2.7.6.21.</strong> Rect (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/scroll_bar.html"><strong aria-hidden="true">2.7.6.22.</strong> Scroll bar (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/scroll_panel.html"><strong aria-hidden="true">2.7.6.23.</strong> Scroll panel (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/scroll_viewer.html"><strong aria-hidden="true">2.7.6.24.</strong> Scroll viewer (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/stack_panel.html"><strong aria-hidden="true">2.7.6.25.</strong> Stack panel (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/tab_control.html"><strong aria-hidden="true">2.7.6.26.</strong> Tab control (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/text.html"><strong aria-hidden="true">2.7.6.27.</strong> Text</a></li><li class="chapter-item expanded "><a href="rg3d/ui/text_box.html"><strong aria-hidden="true">2.7.6.28.</strong> Text box (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/tree.html"><strong aria-hidden="true">2.7.6.29.</strong> Tree (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/vector_image.html"><strong aria-hidden="true">2.7.6.30.</strong> Vector image (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/window.html"><strong aria-hidden="true">2.7.6.31.</strong> Window (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/ui/wrap_panel.html"><strong aria-hidden="true">2.7.6.32.</strong> Wrap panel (WIP)</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="rg3d/serialization/serialization.html"><strong aria-hidden="true">2.8.</strong> Serialization (WIP)</a></li><li class="chapter-item expanded "><a href="rg3d/resources/resources.html"><strong aria-hidden="true">2.9.</strong> Resource Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/resources/model.html"><strong aria-hidden="true">2.9.1.</strong> 3D Models</a></li><li class="chapter-item expanded "><a href="rg3d/resources/texture.html"><strong aria-hidden="true">2.9.2.</strong> Textures</a></li><li class="chapter-item expanded "><a href=".rg3d/resources/sound.html"><strong aria-hidden="true">2.9.3.</strong> Sound Buffers</a></li></ol></li><li class="chapter-item expanded "><a href="rg3d/tutorials/tutorials.html"><strong aria-hidden="true">2.10.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/tutorials/fps/intro.html"><strong aria-hidden="true">2.10.1.</strong> FPS Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">2.10.1.1.</strong> Character controller</a></li><li class="chapter-item expanded "><a href="rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html"><strong aria-hidden="true">2.10.1.2.</strong> Weapons</a></li><li class="chapter-item expanded "><a href="rg3d/tutorials/fps/tutorial-3/tutorial-part-3.html"><strong aria-hidden="true">2.10.1.3.</strong> Bots and AI</a></li></ol></li><li class="chapter-item expanded "><a href="rg3d/tutorials/rpg/intro.html"><strong aria-hidden="true">2.10.2.</strong> RPG Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rg3d/tutorials/rpg/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">2.10.2.1.</strong> Character controller</a></li><li class="spacer"></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="rusty-editor/introduction.html"><strong aria-hidden="true">3.</strong> rusty-editor</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rusty-editor/overview.html"><strong aria-hidden="true">3.1.</strong> Overview</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rg3d Cheat Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rg3d-cheatguide-book"><a class="header" href="#rg3d-cheatguide-book">rg3d Cheat/Guide Book</a></h1>
<p>Practical reference and user guides for <a href="https://github.com/rg3dengine/rg3d">rg3d game engine</a> and
<a href="https://github.com/rg3dengine/rusty-editor">rusty-editor</a>.</p>
<p>The book is in early development stage, you can help to improve it by making a contribution in its
<a href="https://github.com/rg3d-book/rg3d-book.github.io">repository</a>. Don't be shy, every tip is helpful!</p>
<h2 id="how-to-read-the-book"><a class="header" href="#how-to-read-the-book">How to read the book</a></h2>
<p>Almost every chapter in this book can be read in any order, but we recommend reading Chapter 1 and then going
through the First-Person Shooter Tutorial while learning more about specific areas that interest you from the 
other chapters.</p>
<h2 id="support-the-development"><a class="header" href="#support-the-development">Support the development</a></h2>
<p>The future of the project fully depends on community support, every bit is important!</p>
<p><a href="https://www.patreon.com/mrdimas"><img src="https://c5.patreon.com/external/logo/become_a_patron_button.png" alt="Become a patron!" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rg3d"><a class="header" href="#rg3d">rg3d</a></h1>
<p>rg3d is a feature-rich, general purpose game engine that is suitable for any kind of games. It is capable to power
games with small- or medium-sized worlds, large-sized world most likely will require some manual work. This chapter
of the book will help you to get familiar with core engine concepts and will help you start writing your first game!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Despite the look of it, the engine is quite friendly to newcomers, especially with some good guides. This section
of the book will guide you the basics of the engine.</p>
<p>To begin using the engine, just add following lines to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rg3d = &quot;^0.23.1&quot; # Please check crates.io for actual version. 
</code></pre>
<p>Check the next chapter to create a simple application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="framework"><a class="header" href="#framework">Framework</a></h1>
<p>The engine offers special framework to start making games as quickly as possible. It cares about engine initialization,
handles window events, calls every required methods and so on. In other words it helps you to get started as quickly
as possible with a need to put dozens lines of code to just create a window with a game loop.</p>
<p>The simplest app could be created with this code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate rg3d;
</span>
use rg3d::{
    engine::Engine,
    engine::framework::prelude::*,
};

struct Game { }

impl GameState for Game {
    fn init(_engine: &amp;mut Engine) -&gt; Self where Self: Sized {
        Self { }
    }
}

fn main() {
    Framework::&lt;Game&gt;::new()
        .unwrap()
        .title(&quot;Simple&quot;)
        .run();
}
</code></pre></pre>
<p>The &quot;work-horse&quot; here is the <code>GameState</code> trait, it offers some optional method that could be used depending on
your needs.</p>
<ul>
<li><code>fn init(engine: &amp;mut Engine) -&gt; Self where Self: Sized</code> - should create the instance of your game. It accepts the engine instance as the first argument
which gives you full access to the engine during the initialization.</li>
<li><code>fn on_tick(&amp;mut self, engine: &amp;mut Engine, dt: f32, control_flow: &amp;mut ControlFlow)</code> - the game loop, it will
be called at fixed 60 FPS rate allowing you to run your game logic. The method gives you full access to the engine
so you're able to work it freely. The <code>dt</code> argument returns the amount of seconds that passed from the previous
call. The last argument (<code>control_flow</code>) allowing you to change the execution flow, for example setting it to
<code>ControlFlow::Exit</code> will force the game to quit.</li>
<li><code>fn on_ui_message(&amp;mut self, engine: &amp;mut Engine, message: UiMessage)</code> - the main function that listens events
from the user interface and gives you the ability to react. You should handle your UI in here.</li>
<li><code>fn on_device_event(&amp;mut self, engine: &amp;mut Engine, device_id: DeviceId, event: DeviceEvent)</code> - the function that
allows you to handle input from physical devices (mouse, keyboard, gamepads, etc.).</li>
<li><code>fn on_window_event(&amp;mut self, engine: &amp;mut Engine, event: WindowEvent)</code> - the function that allows you to do
something when the window of the game receives an event from operating system. The variety of events is large, and
everything depends on what you need. For example this method could be useful handle keyboard events.</li>
<li><code>fn on_exit(&amp;mut self, engine: &amp;mut Engine)</code> - the function that will be called right before your application
about to shut down allowing you to do some clean up or some other actions.</li>
</ul>
<p>As you can see it is very concise and simple, every method serves a particular purpose. The most important method is
<code>on_tick</code>, it the place where all your game logic will be updated. To demonstrate this, let's add simple animation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">  core::color::{Color, Hsv},
</span><span class="boring">  engine::{framework::prelude::*, Engine},
</span><span class="boring">  event_loop::ControlFlow,
</span><span class="boring">};
</span>struct Game {
    hue: f32,
}

impl GameState for Game {
    fn init(_engine: &amp;mut Engine) -&gt; Self
    where
        Self: Sized,
    {
        Self { hue: 0.0 }
    }

    // Implement a function that will update game logic and will be called at fixed rate of 60 Hz.
    fn on_tick(&amp;mut self, engine: &amp;mut Engine, dt: f32, _: &amp;mut ControlFlow) {
        // Increase hue at fixed rate of 24 degrees per second.
        self.hue += 24.0 * dt;

        // Slowly change color of the window.
        engine
            .renderer
            .set_backbuffer_clear_color(Color::from(Hsv::new(self.hue % 360.0, 100.0, 100.0)))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This piece of code will slowly change the background color of the window going through all colors of rainbow. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-game-loop-wip"><a class="header" href="#custom-game-loop-wip">Custom game loop (WIP)</a></h1>
<p>The framework might be limiting for some cases, in such situations the engine could be initialized manually. It
requires some decent amount of code and could error-prone for beginners. You should use custom game loop only if
you're experienced game developer!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene-and-scene-graph"><a class="header" href="#scene-and-scene-graph">Scene and scene graph</a></h1>
<p>When you're playing a game, you often see various objects scattered around on screen, all of them forming a
<em>scene</em>. Scene is just a set of various objects, as in many other game engines, rg3d allows you to create multiple
scenes for various purposes. For example, one scene could be used for menu, a bunch could be used for game levels,
and one for ending screen. Scenes also could be used to create a source of data for other scenes, such scenes called
<em>prefabs</em>. A scene could also be rendered in a texture, and the texture can be used in other scene - this way you
can create interactive screens that showing some other places.</p>
<p>While playing games, you could've noticed that some objects behaves like they're linked to other objects, for example
your character in a role-playing game could carry a sword. While the character holds the sword, it is linked to his
arm. Such relations between the objects could be presented by a graph structure.</p>
<p>Simply speaking, graph is a set of objects with hierarchical relationships between each object. Each object in the
graph is called <em>node</em>. In the example with the sword and the character, the sword is a <em>child</em> node of a character,
which in its turn is a <em>parent</em> node of a character. (Here we intentionally omit the fact that usually character
model contains complex skeleton with multiple bones and the sword is actually attached to one of hand's bones.)</p>
<h2 id="building-blocks-or-scene-nodes"><a class="header" href="#building-blocks-or-scene-nodes">Building blocks or scene nodes</a></h2>
<p>The engine offers various types of &quot;building blocks&quot; for your scene, each such block is called <em>scene node</em>.</p>
<ul>
<li><strong>Base</strong> - a node that stores hierarchical information (a handle to the parent node and a set of handles
to children nodes), local and global transform, name, tag, lifetime, etc. It has self-describing name - it
is used as a base node for every other scene node (via composition).</li>
<li><strong>Mesh</strong> - a node that represents a 3D model. This one of the most commonly used nodes in almost every game.
Meshes could be easily created either programmatically, or be made in some 3D modelling software (like Blender)
and loaded in your scene.</li>
<li><strong>Light</strong> - a node that represents a light source. There are three types of light sources:
<ul>
<li><strong>Directional</strong> - a light source that does not have position, only direction. The closest real-world example
is our Sun.</li>
<li><strong>Point</strong> - a light source that emits light in every direction. Real-world example: light bulb.</li>
<li><strong>Spot</strong> - a light source that emits light in a particular direction with a cone-like shape. Real-world example:
flashlight.</li>
</ul>
</li>
<li><strong>Camera</strong> - a node that allows you to see the world. You must have at least one camera in your scene to be
able to see anything.</li>
<li><strong>Sprite</strong> - a node that represents a quad that always faced towards a camera. It can have a texture, size, it
also can be rotated around the &quot;look&quot; axis.</li>
<li><strong>Particle system</strong> - a node that allows you to build visual effects using a huge set of small particles, it
can be used to create smoke, sparks, blood splatters, etc. effects.</li>
<li><strong>Terrain</strong> - a node that allows you to create complex landscapes with minimal effort.</li>
<li><strong>Decal</strong> - a node that paints on other nodes using a texture. It is used to simulate cracks in concrete walls,
damaged parts of the road, blood splatters, bullet holes, etc.</li>
</ul>
<p>These scene nodes allow you to build almost any kind of game.</p>
<h2 id="local-and-global-coordinates"><a class="header" href="#local-and-global-coordinates">Local and global coordinates</a></h2>
<p>Graph describes your scene in a very natural way, allowing you think in terms of relative and absolute coordinates
when working with <em>scene nodes</em>.</p>
<p>Scene node has two kinds of transform - local and global. Local transform defines where the node is located
(translation) relative to origin, how much it is scaled (in percent) and rotated (around any arbitrary axis).
Global transform is almost the same, but it also includes the whole chain of transforms of parent nodes. In the
previous example with the character, the sword has its own local transform which tells how much it should be
moved from origin to be exactly on a hand of the character. But global transform of the swords includes transform
of the entire character. So if you move the character, the local transform of the sword will remain the same, but
global transform will include the transform of the character.</p>
<p>This mechanism is very simple, yet powerful. The full grace of it unfolds when you're working with 3D models with
skeleton, each bone in the skeleton has its parent and a set of children. You can rotate/translate/scale bones to
animate your character.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-management"><a class="header" href="#data-management">Data management</a></h1>
<p>The engine uses generation arenas (pools in engine's terminology) for efficient data management. Pool is a
vector with entries that can be either vacant or occupied. Each entry, no matter occupied it or vacant, also
stores a special number called <em>generation</em>. The generation number is used to understand whether an entry has
been changed over time or not. When an entry is reused, its generation number is increased leaving all previously
created handle leading to the entry invalid. This is a very simple and efficient algorithm for tracking the
&quot;lifetime&quot; of the objects.</p>
<p>To access the data in entries, the engine uses <em>handles</em>. The handle is a pair of index of an entry and a
<em>generation</em> number. When you put an object in the pool, it gives you the handle that &quot;leads&quot; to the object.
At this moment the generation of the handle matches the generation of the corresponding entry so the handle
is valid. It will remain valid util you &quot;free&quot; the object, which will make the entry vacant again.</p>
<h2 id="advantages"><a class="header" href="#advantages">Advantages</a></h2>
<p>Since the pool is just a contiguous memory block, it is much more CPU cache-friendly. This means that in most
cases the data portions will be loaded in CPU caches, making the access to the data blazing fast.</p>
<p>Almost every entity in the engine &quot;lives&quot; in its own pool, this make it easy to create such data structures
like graphs, where a node refers to other nodes. In this case scene nodes stores just handles (which is just
8 bytes of memory) to other nodes.</p>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>Once an object was placed in a pool, you have to use respective handle to get a reference to it. This could 
be done either with <code>.borrow[_mut](handle)</code> or by using <code>Index</code> trait: <code>pool[handle]</code>. These methods panic
when handle is invalid, if you want to prevent that, use <code>try_borrow[_mut](handle)</code> method.</p>
<h2 id="freeing"><a class="header" href="#freeing">Freeing</a></h2>
<p>You can extract an object from a pool by calling <code>pool.free(handle)</code>, it will give you the object back, making
all handles to the object invalid.</p>
<h2 id="take--reserve"><a class="header" href="#take--reserve">Take &amp; reserve</a></h2>
<p>Sometimes you may need to temporarily extract an object from a pool, do something with it and then put it back
while preserving handles to that object. There are three special methods for that:</p>
<ol>
<li><code>take_reserve</code> + <code>try_take_reserve</code> - moves object out of the pool, but leaves the entry in &quot;occupied&quot; state. This function returns
a tuple with two values <code>(Ticket&lt;T&gt;, T)</code>. The latter value is obviously is your object, but the first object is 
more interesting. It is a special wrapper over object index that allows you to return the object back. It is used
in <code>put_back</code> method. <strong>Caveat:</strong> an attempt to borrow moved object in the pool will cause panic! </li>
<li><code>put_back</code> - moves the object back in the pool using given ticket. Ticket says where to put the object in the 
pool. </li>
<li><code>forget_ticket</code> - makes the entry of the pool vacant again. It is useful in situations when you've moved object
out of the pool, but for some reason you don't want to return it back in pool, in this case you <strong>must</strong> call
this method, otherwise the corresponding entry will be unusable.</li>
</ol>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<p>There are few possible iterators, each one is useful for particular purpose:</p>
<ol>
<li><code>iter/iter_mut</code> - creates an iterator that iterates over occupied pool entries returning references to an 
object associated with an entry.</li>
<li><code>pair_iter/pair_iter_mut</code> - creates an iterator that iterates over occupied pool entries returning tuples with
two elements <code>(handle, reference)</code>. </li>
</ol>
<h2 id="direct-access"><a class="header" href="#direct-access">Direct access</a></h2>
<p>There is ability to get an object from a pool using only indices, there are two methods for that <code>at</code> and <code>at_mut</code>.</p>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>Sometimes you may need to check if a handle is valid, to do that use <code>is_valid_handle</code> method.</p>
<h2 id="type-erased-handles"><a class="header" href="#type-erased-handles">Type-erased handles</a></h2>
<p>The pool module offers type-erased handles that could be useful for some situations. Try to avoid using type-erased
handles, because they may introduce hardly-reproducible bugs and type safety is always good :)</p>
<p>Type-erased handle is called <code>ErasedHandle</code> and it can be created either manually, or from strongly-typed handles.
Both handle types are interchangeable, you can use <code>From</code> and <code>Into</code> traits to convert them one into another.</p>
<h2 id="special"><a class="header" href="#special">Special</a></h2>
<p>Uncategorized stuff.</p>
<h3 id="getting-a-handle-of-an-object-by-its-reference"><a class="header" href="#getting-a-handle-of-an-object-by-its-reference">Getting a handle of an object by its reference</a></h3>
<p>Sometimes you may need to get a handle of an object having only a reference to it, there is a <code>handle_of</code> method
exactly for that.</p>
<h3 id="iterate-over-and-discard-unnecessary-objects"><a class="header" href="#iterate-over-and-discard-unnecessary-objects">Iterate over and discard unnecessary objects</a></h3>
<p>There is a <code>retain</code> method for that, it allows you to &quot;filter&quot; your pool using a closure with custom filtering
logic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene"><a class="header" href="#scene">Scene</a></h1>
<p>Scene is a container for game entities. Currently, scenes in the engine manage following entities:</p>
<ol>
<li>Graph</li>
<li>Animations</li>
<li>Physics (rigid bodies, colliders, joints)</li>
<li>Sound </li>
</ol>
<p>Scene allows you to create isolated &quot;world&quot; which won't interact with other scenes, it is very useful for many
more or less complex games.</p>
<h2 id="how-to-create"><a class="header" href="#how-to-create">How to create</a></h2>
<p>A scene could be created either in rusty-editor or programmatically. You can also combine both approaches, where
you build all &quot;static&quot; content in the editor and adding rest of the entities (bots, interactive objects, etc.)
manually.</p>
<h3 id="using-rusty-editor"><a class="header" href="#using-rusty-editor">Using rusty-editor</a></h3>
<p>There is a <a href="rg3d/scene/../../rusty-editor/introduction.html">separate chapter</a> in the book that should help you to create a scene.</p>
<p>After a scene is created, you can load it as any other 3D model using the resource manager:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    engine::resource_manager::{MaterialSearchOptions, ResourceManager},
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>
fn load_scene(resource_manager: ResourceManager) -&gt; Scene {
    // Create parent scene.
    let mut scene = Scene::new();

    // Request child scene and block until it loading.
    let scene_resource = block_on(
        resource_manager
            .request_model(&quot;path/to/your/scene.rgs&quot;, MaterialSearchOptions::RecursiveUp),
    )
        .unwrap();

    // Create an instance of the scene in the parent scene.
    let child_scene = scene_resource.instantiate_geometry(&amp;mut scene);

    scene
}
<span class="boring">}
</span></code></pre></pre>
<p>Please note that here we're creating an empty scene and only then instantiating another scene into it. Why is this
needed? </p>
<p><strong>Short answer:</strong> child scene is considered as prefab, and it is &quot;instantiated&quot; in the parent scene. Considering 
it as prefab allows you modifying your scene separately and serialization/deserialization will be able to correctly
apply any changes in the scene.</p>
<p><strong>Long answer:</strong> the engine has a prefab system which allows you to build hierarchical scenes which can include any
number of other scenes as child scenes. Child scenes can have their own child scenes and so on. This is very 
efficient decoupling mechanism that allows you to put pieces of the scene in separate scenes (prefabs) and modify
them independently. The changes in child scenes will be automatically reflected to all parent scenes. Here is the
very simple example of why this is important: imagine you need to populate a town with 3D models of cars. Each
kind of car have its own 3D model and, for example, a collision body that won't allow the player to walk through
cars. How would you do this? The simplest (and dumbest) solution is to copy dozens of car models in the scene, and
you're done. Imagine that now you need to change something in your car, for example, add a trunk that can be opened.
What will you do? Of course, you should &quot;iterate&quot; over each car model and do the required changes, you simply don't have
any other option. This will eat huge amount of time and in general it is very non-productive.</p>
<p>This is where prefabs will save you hours of work. All you need to do is to create a car prefab and instantiate it
multiple times in your scene. When you'll need to change something in the car, you simply go to the prefab and change
it. After that every prefab instance will have your changes!</p>
<h3 id="create-scene-manually"><a class="header" href="#create-scene-manually">Create scene manually</a></h3>
<p>A scene could also be created manually:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{core::pool::Handle, engine::Engine, scene::Scene};
</span>
fn create_scene(engine: &amp;mut Engine) -&gt; Handle&lt;Scene&gt; {
    let mut scene = Scene::new();

    // Use node builders, create sounds, add physics, etc. here to fill the scene.

    engine.scenes.add(scene)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="where-all-my-scenes-located"><a class="header" href="#where-all-my-scenes-located">Where all my scenes located?</a></h2>
<p>All scenes &quot;lives&quot; in the engine, the engine has single ownership over your scene after you've added it in the engine.
You can borrow a scene at any time using its handle and do some changes.</p>
<h2 id="building-scene-asynchronously"><a class="header" href="#building-scene-asynchronously">Building scene asynchronously</a></h2>
<p>You can create your scene in separate thread and then pass it to main thread to insert it in the engine. Why this 
is needed? Remember the last time you've played a relatively large game, you've probably noticed that it have 
loading screens and loading screen has some fancy interactive stuff with progress bar. Loading screen is fully 
responsive while the game doing hard job loading the world for you. Got it already? Asynchronous scene loading is
needed to create/load large scenes with tons of resources without blocking main thread, thus leaving the game 
fully responsive. </p>
<p>There is comprehensive example of asynchronous scene loading, it can be found 
<a href="https://github.com/rg3dengine/rg3d/blob/master/examples/async.rs">here</a></p>
<h2 id="managing-multiple-scenes"><a class="header" href="#managing-multiple-scenes">Managing multiple scenes</a></h2>
<p>Usually you should have only one scene active (unless you're making something very special), you should use 
<code>.enabled</code> flag of a scene to turn it off or on. Deactivated scenes won't be rendered, the physics won't be
updated, the sound will stop, and so on. In other words the scene will be frozen. This is useful for situations
when you often need to switch between scenes, leaving other scene in frozen state. One of the examples where this
can be useful is menus. In most games when you're entering the menu, game world is paused. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph"><a class="header" href="#graph">Graph</a></h1>
<p>Graph is a set of objects with hierarchical relationships between each object. It is one of the most important 
entities in the engine. Graph takes care of your scene objects and does a lot of job for you.</p>
<h2 id="how-to-create-1"><a class="header" href="#how-to-create-1">How to create</a></h2>
<p>You don't need to create graph manually, every scene has its own instance of the graph. It can be accessed pretty
easily: <code>scene_ref.graph</code></p>
<h2 id="adding-nodes"><a class="header" href="#adding-nodes">Adding nodes</a></h2>
<p>There are two ways of adding nodes to the graph, either using <em>node builders</em> or manually, by calling <code>graph.add_node</code>.</p>
<h3 id="using-node-builders"><a class="header" href="#using-node-builders">Using node builders</a></h3>
<p>Every node in the engine has its respective builder, which can be used to create an instance of the node. Using
builders is a preferable way to create scene nodes. There are following node builders:</p>
<ol>
<li><code>BaseBuilder</code> - creates an instance of base node. See <a href="rg3d/scene/./base_node.html">Base node</a> for more info.</li>
<li><code>CameraBuilder</code> - creates an instance of camera node. See <a href="rg3d/scene/./camera_node.html">Camera node</a> for more info.</li>
<li><code>MeshBuilder</code> - creates an instance of mesh node. See <a href="rg3d/scene/./mesh_node.html">Mesh node</a> for more info.</li>
<li><code>LightBuilder</code> - creates an instance of light node. See <a href="rg3d/scene/./light_node.html">Light node</a> for more info.</li>
<li><code>SpriteBuilder</code> - creates an instance of sprite node. See <a href="rg3d/scene/./sprite_node.html">Sprite node</a> for more info.</li>
<li><code>ParticleSystemBuilder</code> - creates an instance of particle system node. 
See <a href="rg3d/scene/./particle_system_node.html">Particle system node</a> for more info.</li>
<li><code>TerrainBuilder</code> - creates an instance of terrain node. See <a href="rg3d/scene/./terrain_node.html">Terrain node</a> for more info.</li>
<li><code>DecalBuilder</code> - creates an instance of decal node. See <a href="rg3d/scene/./decal_node.html">Decal node</a> for more info.</li>
</ol>
<p>Every builder, other than <code>BaseBuilder</code>, accepts <code>BaseBuilder</code> as a parameter in <code>.new(..)</code> method. Why so?
This is needed, because every node (other than Base) is &quot;derived&quot; from Base via composition and the derived
builder must know how to build Base node. While it may sound confusing, it is actually very useful and clear.
Consider this example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder, camera::CameraBuilder, node::Node, transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_camera(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(
        // Here we passing a base builder. Note that, since we can build Base node separately
        // we can pass any custom values to it while building.
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(2.0, 0.0, 3.0))
                .build(),
        ),
    ) 
    // Here we just setting desired Camera properties.
    .with_fov(60.0f32.to_radians())
    .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, we're creating an instance of BaseBuilder and fill it with desired properties as well as filling
the CameraBuilder's instance properties. This is very flexible mechanism, allowing you to build complex hierarchies
in declarative manner:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder, camera::CameraBuilder, mesh::MeshBuilder, node::Node,
</span><span class="boring">        sprite::SpriteBuilder, transform::TransformBuilder, Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_node(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(
        BaseBuilder::new()
            // Add some children nodes.
            .with_children(&amp;[
                // A staff...
                MeshBuilder::new(
                    BaseBuilder::new()
                        .with_name(&quot;MyFancyStaff&quot;)
                        .with_local_transform(
                            TransformBuilder::new()
                                .with_local_position(Vector3::new(0.5, 0.5, 1.0))
                                .build(),
                        ),
                )
                .build(&amp;mut scene.graph),
                // and a spell.
                SpriteBuilder::new(
                    BaseBuilder::new()
                        .with_name(&quot;MyFancyFireball&quot;)
                        .with_local_transform(
                            TransformBuilder::new()
                                .with_local_position(Vector3::new(-0.5, 0.5, 1.0))
                                .build(),
                        ),
                )
                .build(&amp;mut scene.graph),
            ])
            .with_local_transform(
                TransformBuilder::new()
                    .with_local_position(Vector3::new(2.0, 0.0, 3.0))
                    .build(),
            ),
    )
    .with_fov(60.0f32.to_radians())
    .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>This code snippet create a camera for first-person role-playing game's player, it will have a staff in &quot;right-hand&quot;
and a spell in the left hand. Of course all of this is very simplified, but should give you the main idea. Note
that staff and fireball will be children nodes of camera, and when setting their transform we're actually setting
<strong>local</strong> transform which means that the transform will be relative to camera's. The staff and the spell will move
together with the camera.</p>
<h3 id="adding-a-node-manually"><a class="header" href="#adding-a-node-manually">Adding a node manually</a></h3>
<p>For some rare cases you may also want delay adding a node to the graph, specifically for that purpose, every node 
builder has <code>.build_node</code> method which creates an instance of <code>Node</code>  but does not add it to the graph.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{base::BaseBuilder, camera::CameraBuilder, node::Node, Scene},
</span><span class="boring">};
</span>
fn create_node(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    let node: Node = CameraBuilder::new(BaseBuilder::new()).build_node();

    // We must explicitly add the node to the graph.
    scene.graph.add_node(node)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="how-to-modify-the-hierarchy"><a class="header" href="#how-to-modify-the-hierarchy">How to modify the hierarchy</a></h2>
<p>For many cases you can't use builders to create complex hierarchy, the simplest example of such situation when 
you're creating an instance of some 3D model. If you want the instance to be a child object of some other object,
you should attach it explicitly by using <code>graph.link_nodes(..)</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    engine::resource_manager::{MaterialSearchOptions, ResourceManager},
</span><span class="boring">    scene::{base::BaseBuilder, camera::CameraBuilder, node::Node, Scene},
</span><span class="boring">};
</span>
fn link_weapon_to_camera(
    scene: &amp;mut Scene,
    camera: Handle&lt;Node&gt;,
    resource_manager: ResourceManager,
) {
    let weapon = block_on(
        resource_manager
            .request_model(&quot;path/to/weapon.fbx&quot;, MaterialSearchOptions::RecursiveUp),
    )
    .unwrap()
    .instantiate_geometry(scene);

    // Link weapon to the camera.
    scene.graph.link_nodes(weapon, camera);
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we've loaded a weapon 3D model, instantiated it on scene and attached to <em>existing</em> camera. </p>
<h2 id="how-to-remove-nodes"><a class="header" href="#how-to-remove-nodes">How to remove nodes</a></h2>
<p>A node could be removed by simply calling <code>graph.remove_node(handle)</code>, this method removes the node from the 
graph <strong>with all of its children nodes</strong>. Sometimes this is unwanted behaviour, and you want to preserve children
nodes while deleting parent node. To do that you need to explicitly detach children nodes of the node you're about
to delete:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span>
fn remove_preserve_children(scene: &amp;mut Scene, node_to_remove: Handle&lt;Node&gt;) {
    for child in scene.graph[node_to_remove].children().to_vec() {
        scene.graph.unlink_node(child);
    }

    scene.graph.remove_node(node_to_remove);
}
<span class="boring">}
</span></code></pre></pre>
<p>After calling this function, every child node of <code>node_to_remove</code> will be detached from it and the <code>node_to_remove</code>
will be deleted. <code>remove_node</code> has some limitations: it cannot be used to extract &quot;sub-graph&quot; from the graph, it
just drops nodes immediately. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-node"><a class="header" href="#base-node">Base node</a></h1>
<p>Base node is a scene node that stores hierarchical information (a handle to the parent node and a set of handles
to children nodes), local and global transform, name, tag, lifetime, etc. It has self-describing name - it
is used as a base node for every other scene node (via composition).</p>
<p>It has no graphical information, so it is invisible all the time, but it is useful as a &quot;container&quot; for children
nodes.</p>
<h2 id="how-to-create-2"><a class="header" href="#how-to-create-2">How to create</a></h2>
<p>Use the <code>BaseBuilder</code> to create an instance of the Base node:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::scene::{base::BaseBuilder, Scene};
</span><span class="boring">fn build_node(scene: &amp;mut Scene) {
</span>let handle = BaseBuilder::new().build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="building-a-complex-hierarchy"><a class="header" href="#building-a-complex-hierarchy">Building a complex hierarchy</a></h2>
<p>To build a complex hierarchy of some nodes, use <code>.with_children()</code> method of the <code>BaseBuilder</code>, it allows you
to build a hierarchy of any complexity:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::scene::{base::BaseBuilder, camera::CameraBuilder, Scene};
</span><span class="boring">
</span><span class="boring">fn build_node(scene: &amp;mut Scene) {
</span>let handle = BaseBuilder::new()
    .with_children(&amp;[
        CameraBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph),
        BaseBuilder::new()
            .with_children(&amp;[BaseBuilder::new().build(&amp;mut scene.graph)])
            .build(&amp;mut scene.graph),
    ])
    .build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Note that when we're building a <code>Camera</code> instance, we're passing a new instance of <code>BaseBuilder</code> to it, this
instance can also be used to set some properties and a set of children nodes.</p>
<p>The &quot;fluent syntax&quot; is not mandatory to use, the above code snipped could be rewritten like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::scene::{base::BaseBuilder, camera::CameraBuilder, Scene};
</span><span class="boring">
</span><span class="boring">fn build_node(scene: &amp;mut Scene) {
</span>let camera = CameraBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);

let child_base = BaseBuilder::new().build(&amp;mut scene.graph);

let base = BaseBuilder::new()
    .with_children(&amp;[child_base])
    .build(&amp;mut scene.graph);

let handle = BaseBuilder::new()
    .with_children(&amp;[camera, base])
    .build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>However, it looks less informative, because it loses the hierarchical view and it is harder to tell the relations
between objects.</p>
<h2 id="transform"><a class="header" href="#transform">Transform</a></h2>
<p>Base node has a local transform that allows you to translate/scale/rotate/etc. your node as you want to. For example,
to move a node at specific location you could use this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">   core::{algebra::Vector3, pool::Handle},
</span><span class="boring">   scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn translate_node(scene: &amp;mut Scene, node_handle: Handle&lt;Node&gt;) {
</span>scene.graph[node_handle]
    .local_transform_mut()
    .set_position(Vector3::new(1.0, 0.0, 2.0));
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>You could also chain multiple <code>set_x</code> calls, like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">   core::{algebra::Vector3, pool::Handle},
</span><span class="boring">   scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn transform_node(scene: &amp;mut Scene, node_handle: Handle&lt;Node&gt;) {
</span>scene.graph[node_handle]
    .local_transform_mut()
    .set_position(Vector3::new(1.0, 0.0, 2.0))
    .set_scale(Vector3::new(2.0, 2.0, 2.0))
    .set_rotation_offset(Vector3::new(1.0, 1.0, 0.0));
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesh-node"><a class="header" href="#mesh-node">Mesh node</a></h1>
<p>Mesh is a scane node that represents a 3D model. This one of the most commonly used nodes in almost every game.
Meshes could be easily created either programmatically, or be made in some 3D modelling software (like Blender)
and loaded in your scene.</p>
<h2 id="how-to-create-3"><a class="header" href="#how-to-create-3">How to create</a></h2>
<p>There are basically two ways, how to pick one depends your needs. In general, using a 3D modelling software is
the way to go, especially with tons and tons of free 3D models available online.</p>
<p><strong>Caveat:</strong> The engine supports <em>only</em> FBX file format for 3D models!</p>
<h3 id="using-a-3d-modelling-software"><a class="header" href="#using-a-3d-modelling-software">Using a 3D modelling software</a></h3>
<p>To create 3D model in you could use <a href="https://www.blender.org/">Blender</a> and then export it to <code>FBX</code> file format.
To load your 3D model in the game, you should do few simple steps:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span>
use rg3d::{
    core::{futures::executor::block_on, pool::Handle},
    engine::resource_manager::{MaterialSearchOptions, ResourceManager},
    scene::{node::Node, Scene},
};
use std::path::Path;

fn load_model_to_scene(
    scene: &amp;mut Scene,
    path: &amp;Path,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    // Request model resource and block until it loading. 
    let model_resource =
        block_on(resource_manager.request_model(path, MaterialSearchOptions::RecursiveUp))
            .unwrap();

    // Create an instance of the resource in the scene. 
    model_resource.instantiate_geometry(scene)
}
<span class="boring">}
</span></code></pre></pre>
<p>This code snippet intentionally omits proper <code>async/await</code> usage (instead it just blocks current thread until
model is loading) and error handling. In the real game you should carefully handle all errors and use <code>async/await</code>
properly.</p>
<h3 id="creating-a-procedural-mesh"><a class="header" href="#creating-a-procedural-mesh">Creating a procedural mesh</a></h3>
<p>A mesh instance could be created from code, such meshes called &quot;procedural&quot;. They're suitable for cases when you
cannot create a mesh in 3D modelling software.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span>
use rg3d::{
    core::{
        algebra::{Matrix4, Vector3},
        parking_lot::Mutex,
        pool::Handle,
        sstorage::ImmutableString,
    },
    engine::resource_manager::ResourceManager,
    material::{shader::SamplerFallback, Material, PropertyValue},
    scene::{
        base::BaseBuilder,
        mesh::{
            surface::{SurfaceBuilder, SurfaceData},
            MeshBuilder,
        },
        node::Node,
        transform::TransformBuilder,
        Scene,
    },
};
use std::sync::Arc;

fn create_procedural_mesh(
    scene: &amp;mut Scene,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    let mut material = Material::standard();

    // Material is completely optional, but here we'll demonstrate that it is possible to
    // create procedural meshes with any material you want.
    material
        .set_property(
            &amp;ImmutableString::new(&quot;diffuseTexture&quot;),
            PropertyValue::Sampler {
                value: Some(resource_manager.request_texture(&quot;some_texture.jpg&quot;, None)),
                fallback: SamplerFallback::White,
            },
        )
        .unwrap();

    // Notice the MeshBuilder.
    MeshBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, -0.25, 0.0))
                .build(),
        ),
    )
    .with_surfaces(vec![SurfaceBuilder::new(Arc::new(Mutex::new(
        // Our procedural mesh will have a form of squashed cube.
        // A mesh can have unlimited amount of surfaces.
        SurfaceData::make_cube(Matrix4::new_nonuniform_scaling(&amp;Vector3::new(
            25.0, 0.25, 25.0,
        ))),
    )))
        .with_material(Arc::new(Mutex::new(material)))
        .build()])
    .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, creating a mesh procedurally requires lots of manual work and not so easy.</p>
<h2 id="animation"><a class="header" href="#animation">Animation</a></h2>
<p>Meshes have full support of bone animation, it means that you can load pretty much any model in your game, and 
it will play animation with no problems. One difference that should be noted is that you should use <code>instantiate</code>
method instead of <code>instantiate_geometry</code> and then manually apply animation to the mesh in you game loop.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::resource::model::ModelInstance;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    engine::resource_manager::{MaterialSearchOptions, ResourceManager},
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>
fn load_model_to_scene(
    scene: &amp;mut Scene,
    path: &amp;Path,
    resource_manager: ResourceManager,
) -&gt; ModelInstance {
    // Request model resource and block until it loading.
    let model_resource =
        block_on(resource_manager.request_model(path, MaterialSearchOptions::RecursiveUp))
            .unwrap();

    // Create an instance of the resource in the scene.
    model_resource.instantiate(scene)
}

<span class="boring">fn animate(scene: &amp;mut Scene, resource_manager: ResourceManager) {
</span>// At initialization.
let ModelInstance { root, animations } = load_model_to_scene(
    scene,
    &amp;Path::new(&quot;path/to/your/model.fbx&quot;),
    resource_manager,
);

// .. Somewhere in the game loop ..

scene.animations[animations[0]]
    .get_pose()
    .apply(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="retargetting"><a class="header" href="#retargetting">Retargetting</a></h3>
<p>You don't have to store all possible animations inside a single 3D model file, instead you can store each animation
in separate file and retarget it to your mesh instance when needed. This also allows you to store non-animated
3D model in separate file, and all animations in their own files.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="light-node"><a class="header" href="#light-node">Light node</a></h1>
<p>The engine offers complex lighting system with various types of light sources. </p>
<h2 id="light-types"><a class="header" href="#light-types">Light types</a></h2>
<p>There are three main types of light sources: directional, point, and spot lights.</p>
<h3 id="directional-light"><a class="header" href="#directional-light">Directional light</a></h3>
<p>Directional light does not have a position, its rays are always parallel,and it has a particular direction in space.
An example of directional light in real-life could be our Sun. Even if it is a point light, it is so far away from
the Earth, so we can assume that its rays are always parallel. Directional light sources are suitable for outdoor 
scenes.</p>
<p>A directional light source could be created something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{directional::DirectionalLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_directional_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    DirectionalLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new()))
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, the light source will be oriented to lit &quot;the ground&quot;. In other words its direction will be faced towards
<code>(0.0, -1.0, 0.0)</code> vector. You can rotate it as you want by setting local transform of it while building. Something
like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{directional::DirectionalLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_directional_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    DirectionalLightBuilder::new(BaseLightBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_rotation(UnitQuaternion::from_axis_angle(
                    &amp;Vector3::x_axis(),
                    -45.0f32.to_radians(),
                ))
                .build(),
        ),
    ))
    .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="point-light"><a class="header" href="#point-light">Point light</a></h3>
<p>Point light is a light source that emits lights in all directions, it has a position, but does not have an orientation.
An example of a point light source: light bulb. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{point::PointLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_point_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    PointLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new()))
        .with_radius(5.0)
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="spotlight"><a class="header" href="#spotlight">Spotlight</a></h3>
<p>Spot light is a light source that emits lights in cone shape, it has a position and orientation. An example of 
a spot light source: flashlight.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{spot::SpotLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_spot_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    SpotLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new()))
        .with_distance(5.0)
        .with_hotspot_cone_angle(50.0f32.to_radians())
        .with_falloff_angle_delta(10.0f32.to_radians())
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="light-scattering"><a class="header" href="#light-scattering">Light scattering</a></h2>
<p>Spot and point lights supports light scattering effect. Imagine you're walking with a flashlight in a foggy weather,
the fog will scatter the light from your flashlight making it, so you'll see the &quot;light volume&quot;. Light scattering is
<strong>enabled by default</strong>, so you don't have to do anything to enable it. However, in some cases you might want to disable 
it, you can do this either while building a light source or change light scattering options on existing light source.
Here is the small example how to do that.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span>
fn disable_light_scatter(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;) {
    scene.graph[light_handle]
        .as_light_mut()
        .enable_scatter(false);
}
<span class="boring">}
</span></code></pre></pre>
<p>You could also change the amount of scattering per each color channel, using this you could imitate the 
<a href="https://en.wikipedia.org/wiki/Rayleigh_scattering">Rayleigh scattering</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span>
fn use_rayleigh_scattering(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;) {
    scene.graph[light_handle]
        .as_light_mut()
        .set_scatter(Vector3::new(0.03, 0.035, 0.055))
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="shadows"><a class="header" href="#shadows">Shadows</a></h2>
<p>Spot and point lights are both supports shadows, however directional light still lacks shadows. There is a
<a href="https://github.com/rg3dengine/rg3d/issues/220">tracking issue</a> for that.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Lights are not very cheap, every light source has some performance impact. As a general rule, try to keep amount
of light sources at reasonable levels and especially try to avoid creating tons of light sources in a small area.
Keep in mind that the less area the light need to &quot;cover&quot;, the higher the performance. This means that you can have
tons of small light sources almost free.</p>
<p>Shadows giving the most significant performance impact, you should keep amount of light sources that can cast
shadows at lowest possible amount to keep performance at good levels. You can also turn on/off shadows when you 
need:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span>
fn switch_shadows(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;, cast_shadows: bool) {
    scene.graph[light_handle]
        .as_light_mut()
        .set_cast_shadows(cast_shadows)
}
<span class="boring">}
</span></code></pre></pre>
<p>Not every light should cast shadows, for example a small light that a player can see only in a distance can have
shadows disabled. You should set the appropriate values depending on your scene, just remember - the fewer shadows
the more performance you'll get. The most expensive shadows are from point lights, the less - from spot lights.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprite"><a class="header" href="#sprite">Sprite</a></h1>
<p>Sprite is just a quad mesh that is always facing camera. It has size, color, rotation around &quot;look&quot; axis and a texture.
Sprites are useful mostly for projectiles, like glowing plasma, and for things that should always face a camera.</p>
<p><strong>Important:</strong> It should be noted that <strong>sprites are not meant to be used for 2D games</strong>, they're only for 3D. 
There is a separate 2D scenes with their own nodes, which are very well optimized for 2D games.</p>
<h2 id="how-to-create-4"><a class="header" href="#how-to-create-4">How to create</a></h2>
<p>A sprite instance could be created using <code>SpriteBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{color::Color, pool::Handle},
</span><span class="boring">    scene::{base::BaseBuilder, node::Node, sprite::SpriteBuilder, Scene},
</span><span class="boring">};
</span>
fn create_sprite(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    SpriteBuilder::new(BaseBuilder::new())
        .with_size(2.0)
        .with_rotation(45.0f32.to_radians())
        .with_color(Color::RED)
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>A sprite with a texture could be created by using <code>.with_texture</code> method of the builder:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span>use rg3d::{
    core::pool::Handle,
    engine::resource_manager::ResourceManager,
    scene::{base::BaseBuilder, node::Node, sprite::SpriteBuilder, Scene},
};

fn create_sprite(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    SpriteBuilder::new(BaseBuilder::new())
        .with_texture(resource_manager.request_texture(&quot;path/to/your/texture.png&quot;, None))
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="general-rules"><a class="header" href="#general-rules">General rules</a></h2>
<p>Sprites <strong>must not</strong> be used to create any visual effects, that involve many particles. You should use particle
systems for that. Why so? Particles systems are very well optimized for managing huge amounts of particles at the
same time, but sprites are not. Each sprite is very heavy to be used as a particle in particle systems, it has
a lot of &quot;useless&quot; info that bloats its size up to 600 bytes. </p>
<p>Currently, the renderer will render each sprite in a separate draw call, which is very inefficient. So you should 
avoid creating lots of sprites.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Sprites are not supporting any sort of lighting, if you need lighted sprites, you need to create your own render
pass and use <code>Mesh</code> node with custom shader that will orient all faces towards camera and will do lighting 
calculations. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="particle-system"><a class="header" href="#particle-system">Particle system</a></h1>
<p>Particle system is a scene node that is used to create complex visual effects (VFX). It operates on huge amount
of particles at once allowing you to do complex simulation that involves large amount of particles. Typically,
particle systems are used to create following visual effects: smoke, sparks, blood splatters, steam, etc. </p>
<p><strong>Important:</strong> Current particle system implementation is <strong>not deterministic</strong>, this means that the state of the
particles will be different at each run of your game. Also you <strong>cannot</strong> rewind the particle system, nor set
a particular position in time. This fact limits potential usages of the particle system, however it is still useful
for any effects that does not have to be deterministic, like sparks, smoke, steam, etc. This is known issue, and
it will eventually be fixed by adding a new kind of particle systems. Tracking issue could be found 
<a href="https://github.com/rg3dengine/rg3d/issues/120">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="particle-system-1"><a class="header" href="#particle-system-1">Particle system</a></h1>
<p>Particle system is a scene node that is used to create complex visual effects (VFX). It operates on huge amount
of particles at once allowing you to do complex simulation that involves large amount of particles. Typically,
particle systems are used to create following visual effects: smoke, sparks, blood splatters, steam, etc. </p>
<p><strong>Important:</strong> Current particle system implementation is <strong>not deterministic</strong>, this means that the state of the
particles will be different at each run of your game. Also you <strong>cannot</strong> rewind the particle system, nor set
a particular position in time. This fact limits potential usages of the particle system, however it is still useful
for any effects that does not have to be deterministic, like sparks, smoke, steam, etc. This is known issue, and
it will eventually be fixed by adding a new kind of particle systems. Tracking issue could be found 
<a href="https://github.com/rg3dengine/rg3d/issues/120">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="camera-node-wip"><a class="header" href="#camera-node-wip">Camera node (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decal-node-wip"><a class="header" href="#decal-node-wip">Decal node (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-wip"><a class="header" href="#animation-wip">Animation (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-wip"><a class="header" href="#rendering-wip">Rendering (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shaders"><a class="header" href="#shaders">Shaders</a></h1>
<p>Shader is a set of programs that runs directly on graphics adapter. Each program from the set is called
<em>sub-shader</em>. Sub-shaders linked with render pass, each render pass defines &quot;where&quot; to draw and an object.
&quot;where&quot; means that you can set up your own render pass and the renderer will use the sub-shader with 
your render pass. For the ease of use there are number of <a href="rg3d/rendering/shaders.html#predefined-render-passes">predefined render passes</a>.</p>
<p>Shaders have properties of various types that can be used together with materials to draw an object. </p>
<h2 id="shaders-language"><a class="header" href="#shaders-language">Shaders language</a></h2>
<p>The engine uses GLSL shading language for every sub-shader. There are numerous of GLSL guides over the 
internet, so there is no need to &quot;re-post&quot; the well documented info again.</p>
<p>There are very few differences:</p>
<ol>
<li>No need to define a version of the shader. Every shader source will be pre-processed, and it will 
get correct version automatically. Preprocessing is needed because the same shader could run on OpenGL
and WebGL (OpenGL ES) which have some differences.</li>
<li>There is a &quot;standard&quot; library of useful methods which is automatically included in every shader source
at preprocessing stage. The library source could be found
<a href="https://github.com/rg3dengine/rg3d/blob/master/src/renderer/framework/shaders/shared.glsl">here</a>. It 
is well documented, and you may find some functions useful for you job.</li>
</ol>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>Shader has rigid structure that could be described in this code snipped:</p>
<pre><code class="language-ron">(
    // A set of properties, there could be any amount of properties.
    properties: [
        (
            // Each property must have a name. This name must match with respective
            // uniforms! That's is the whole point of having properties.
            name: &quot;diffuseTexture&quot;,
            // Value has limited set of possible variants.
            value: Sampler(default: None, fallback: White)
        )
    ],
    // A set of render passes (see next section for more info)
    passes: [
        (
            // Name must match with the name of either standard render pass (see below) or
            // one of your passes.
            name: &quot;Forward&quot;,
            // A set of parameters that regulate renderer pipeline state.
            // This is mandatory field of each render pass.
            draw_parameters: DrawParameters(
                // A face to cull. Either Front or Back.
                cull_face: Some(Back),
                // Color mask. Defines which colors should be written to render target.
                color_write: ColorMask(
                    red: true,
                    green: true,
                    blue: true,
                    alpha: true,
                ),
                // Whether to modify depth buffer or not.
                depth_write: true,
                // Whether to use stencil test or not.
                stencil_test: None,
                // Whether to perform depth test when drawing.
                depth_test: true,
                // Blending options.
                blend: Some(BlendFunc(
                    sfactor: SrcAlpha,
                    dfactor: OneMinusSrcAlpha,
                )),
                // Stencil options.
                stencil_op: StencilOp(
                    fail: Keep,
                    zfail: Keep,
                    zpass: Keep,
                    write_mask: 0xFFFF_FFFF,
                ),
            ),
            // Vertex shader code.
            vertex_shader:
                r#&quot;
                layout(location = 0) in vec3 vertexPosition;
                layout(location = 1) in vec2 vertexTexCoord;
                uniform mat4 rg3d_worldViewProjection;
                out vec2 texCoord;
                void main()
                {
                    texCoord = vertexTexCoord;
                    gl_Position = rg3d_worldViewProjection * vertexPosition;
                }
                &quot;#;
            // Pixel shader code.
            pixel_shader:
                r#&quot;
                // Note that the name of this uniform match the name of the property up above.
                uniform sampler2D diffuseTexture;
                out vec4 FragColor;
                in vec2 texCoord;
                void main()
                {
                    FragColor = diffuseColor * texture(diffuseTexture, texCoord);
                }
                &quot;#;
        )
    ],
)
</code></pre>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p>Property is a named variable of some type. Properties directly tied with the uniforms in the sub-shaders,
for each you can have a property called <code>time</code>, and then you can define <code>uniform float time;</code> in your sub-shader
and the engine will pass property value to that uniform for you before drawing an object. Properties placed in 
a &quot;global namespace&quot;, which means that every sub-shader have &quot;access&quot; to the properties.</p>
<h2 id="built-in-properties"><a class="header" href="#built-in-properties">Built-in properties</a></h2>
<p>There are number of built-in properties, the full list is available
<a href="https://docs.rs/rg3d/0.23.1/rg3d/material/shader/struct.Shader.html#built-in-variables">here</a></p>
<h2 id="predefined-render-passes"><a class="header" href="#predefined-render-passes">Predefined render passes</a></h2>
<p>Predefined render passes helps you to create your own shader without a need to create your own render pass 
and to quickly start writing your shaders.</p>
<ul>
<li><strong>GBuffer</strong> - A pass that fills a set with render target sized textures with various data about each rendered 
object. These textures then are used for physically-based lighting. Use this pass when you want the standard 
lighting to work with your objects.</li>
<li><strong>Forward</strong> - A pass that draws an object directly in render target. This pass is very limiting, it does not 
support lighting, shadows, etc. It should be only used to render translucent objects.</li>
<li><strong>SpotShadow</strong> - A pass that emits depth values for an object, later this depth map will be used to render shadows.</li>
<li><strong>PointShadow</strong> - A pass that emits distance from a fragment to a point light, later this depth map will be used
to render shadows.</li>
</ul>
<h2 id="drawing-parameters"><a class="header" href="#drawing-parameters">Drawing parameters</a></h2>
<p>Drawing parameters defines which GPU functions to use and at which state. For example, to render transparent
objects you need to enable blending with specific blending rules. Or you need to disable culling to draw objects
from both sides. This is when draw parameters comes in handy. There are relatively large list of drawing
parameters, and it could confuse a person who didn't get used to work with graphics. Thankfully there is a good
documentation about this available <a href="https://docs.rs/rg3d/0.23.1/rg3d/material/shader/struct.Shader.html#drawing-parameters">here</a></p>
<h2 id="vertex-shader"><a class="header" href="#vertex-shader">Vertex shader</a></h2>
<p>Vertex shader operates on single vertices, it must provide at least the position of the vertex
in clipping space. In other words it has to do at least this:</p>
<pre><code class="language-glsl">layout(location = 0) in vec3 vertexPosition;

uniform mat4 rg3d_worldViewProjection; // Note the built-in variable.

void main()
{
    gl_Position = rg3d_worldViewProjection * vertexPosition;
}
</code></pre>
<p>This is the simplest vertex shader, using vertex shaders you can create various graphical effects that affects
vertices.</p>
<h2 id="pixel-shader"><a class="header" href="#pixel-shader">Pixel Shader</a></h2>
<p>Pixel shader (or more precisely - fragment shader), operates on a small fragment of your render target. In general
pixels shaders just writes some color to a render target (or multiple targets) using some program.</p>
<pre><code class="language-glsl">out vec4 FragColor;

void main()
{
    FragColor = vec4(1, 0, 0, 1);
}
</code></pre>
<p>This is the simplest pixel shader, it just fills the render target with red color.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="materials"><a class="header" href="#materials">Materials</a></h1>
<p>Material defines a set of values for a shader. Materials usually contains textures (diffuse, normal, height, emission,
etc. maps), numerical values (floats, integers), vectors, booleans, matrices and arrays of each type, except
textures. Each parameter can be changed in runtime giving you the ability to create animated materials. However,
in practice, most materials are static, this means that once it created, it won't be changed anymore.</p>
<p>Please keep in mind that the actual &quot;rules&quot; of drawing an entity are stored in the shader, 
<strong>material is only a storage</strong> for specific uses of the shader. </p>
<p>Multiple materials can share the same shader, for example standard shader covers 95% of most common use cases,
and it is shared across multiple materials. The only difference are property values, for example you can draw
multiple cubes using the same shader, but with different textures.</p>
<p>Material itself can be shared across multiple places as well as the shader. This gives you the ability to render
multiple objects with the same material efficiently.</p>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<p>It is very important re-use materials as much as possible, because the amount of materials used per frame
significantly correlates with performance. The more unique materials you have per frame, the more work has
to be done by the renderer and video driver to render a frame and the more time the frame will require for
rendering, thus lowering your FPS.</p>
<h2 id="standard-material"><a class="header" href="#standard-material">Standard material</a></h2>
<p>The engine offers a standard PBR material, PBR stands for &quot;Physically-Based Rendering&quot; which gives you the quality
of shading which is very close to materials in real world (to some extent of course).</p>
<p>The standard material can cover 95% of use cases, and it is suitable for almost any kind of game, except maybe
some cartoon-ish or stylized games. </p>
<p>The standard material has quite a lot of properties that can be used to fully utilize the power of PBR rendering:</p>
<ul>
<li><strong>diffuseColor</strong> - an RGBA color that will be used as a base color for you object. <strong>Caveat:</strong> the opacity value
(alpha) will be used only with <code>Forward</code> render path! This means that you will need to switch render path on your
mesh (<a href="rg3d/rendering/materials.html#transparency">see below</a>)</li>
<li><strong>diffuseTexture</strong> - a 2D texture containing the unlit &quot;basic&quot; colors of your object, this is the most commonly
used texture. For example, you can assign a brick wall texture to this property and your object will look a brick
wall.</li>
<li><strong>normalTexture</strong> - a 2D texture containing per-pixel normal vectors. </li>
<li><strong>metallicTexture</strong> - a 2D texture containing per-pixel metallic factor, where 0 - dielectric, 1 - metal.
In simple words it defines will your object reflect (1.0) the environment or not (0.0). </li>
<li><strong>roughnessTexture</strong> - a 2D texture containing per-pixel roughness factor, where 0 - completely flat, 1 - 
very rough.</li>
<li><strong>heightTexture</strong> - a 2D texture containing per-pixel displacement value, it is used with parallax mapping to
crate an effect of volume on a flat surface.</li>
<li><strong>emissionTexture</strong> - a 2D texture containing per-pixel emission lighting. You could use this to create emissive
surfaces like small lamps on wall of sci-fi ship, or to create glowing eyes for your monsters that will scare 
the player.</li>
<li><strong>lightmapTexture</strong> - a 2D texture containing per-pixel <strong>static</strong> lighting. It is used to apply precomputed
light to your 3D models, and the most common use case is to lit a static object using a static light. Precomputed
light is very cheap. The engine offers built-in lightmapper that can generated lightmaps for you.</li>
<li><strong>aoTexture</strong> - a 2D texture containing per-pixel shading values, allows you to &quot;bake&quot; shadows in for your 3D
object.</li>
<li><strong>texCoordScale</strong> - a 2D vector that allows you to scale texture coordinates used to sample the textures 
mentioned above (expect lightmaps, they're using separate texture coordinates)</li>
<li><strong>layerIndex</strong> - a natural number that is used for decals masking, a decal will only be applied to your mesh
iff the decal has matching index. </li>
<li><strong>emissionStrength</strong> - a 3D vector that allows you to set the strength of emission per-channel (R, G, B) for 
your <code>emissionTexture</code></li>
</ul>
<h2 id="transparency"><a class="header" href="#transparency">Transparency</a></h2>
<p>The standard material offers very basic transparency support, to use it you have to explicitly switch render
path on you mesh object. It could be done something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{mesh::RenderPath, node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn set_forward_render_path(scene: &amp;mut Scene, mesh_handle: Handle&lt;Node&gt;) {
</span>    scene.graph[mesh_handle]
        .as_mesh_mut()
        .set_render_path(RenderPath::Forward);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>After this your mesh will be rendered using specialized render pass called Forward which supports alpha-blending
and transparent objects. <strong>Caveat:</strong> Current forward renderer implementation does not support any kind of lighting,
if you need lighting, you will need to use custom shader for that!</p>
<h2 id="material-import"><a class="header" href="#material-import">Material import</a></h2>
<p>When you're loading a 3D model in the engine, the engine tries to convert the materials stored inside to standard
material. In most cases there is no way to create 100% matching material on the fly, instead the engine tries 
to its best to make sure the material will be imported as closely as possible to the original. Various 3D modelling
tools uses different material system, but all of them allowing you to export your 3D model in one of the commonly
used formats (such as FBX).</p>
<h3 id="blender"><a class="header" href="#blender">Blender</a></h3>
<p>When using Blender, make sure you using <strong>Principled BSDF</strong> material, it is the closest material that can be converted
to engine's standard material at almost 100% fidelity. </p>
<h3 id="3ds-max"><a class="header" href="#3ds-max">3Ds max</a></h3>
<p>It highly depends on the version of the 3Ds max, but in general the default material should work fine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-wip"><a class="header" href="#sound-wip">Sound (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-wip"><a class="header" href="#physics-wip">Physics (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h1>
<p>rg3d features an extremely powerful and flexible node-based user interface system. Power and flexibility comes with
a certain price: it has a steep learning curve. This chapter will cover user interface usage in the engine, explain
basic concepts, provide information about most commonly used widgets, and so on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic concepts</a></h1>
<p>This chapter should help you understand basic concepts lying in the foundation of the GUI in the engine.</p>
<h2 id="stateful"><a class="header" href="#stateful">Stateful</a></h2>
<p>*<em>Stateful UI</em> means that we can create and destroy widgets when we need to, it is the opposite approach of 
<strong>immediate-mode</strong> or <strong>stateless UIs</strong> when you don't have long-lasting state for your widgets
(usually stateless UI hold its state only for one or two frames). </p>
<p>Stateful UI is much more powerful and flexible, it allows you to have complex layout system without having to 
create hacks to create complex layout as you'd do in immediate-mode UIs. It is also much faster in terms of 
performance.</p>
<p>Stateful UI is a must for complex user interfaces that requires rich layout and high performance. I'm not telling
that you <em>can't</em> do it in immediate mode UI, you can, but using tons of hacks. See <a href="rg3d/ui/basic_concepts/basic_concepts.html#layout">Layout</a> section for
more info.</p>
<h2 id="node-based-architecture"><a class="header" href="#node-based-architecture">Node-based architecture</a></h2>
<p>Every user interface could be represented as a set of small blocks that have hierarchical bonding between each
other. For example a button could be represented using two parts: a background and a foreground. Usually the background
is just a simple rectangle (either a vector or bitmap), and a foreground is a text. The text (the foreground widget)
is a child object of the rectangle (the background widget). These two widgets forms another, more complex widget that
we call button. Graphically it will look like this:</p>
<p><img src="rg3d/ui/basic_concepts/./button.svg" alt="Button" /></p>
<p>On the right side of the image we can see the generic button and on the left side, we can see its hierarchical 
structure. Such approach allows us to modify the look of the button as we wish, we can create a button with 
image background, or with any vector image, or even other widgets. The foreground can be anything too, it can also
contain its own complex hierarchy, like a pair of an icon with a text and so on.</p>
<h2 id="message-passing"><a class="header" href="#message-passing">Message passing</a></h2>
<p>The engine uses message passing mechanism for any UI logic. What does that mean? Let's see at the button from the
previous section and imagine we want to change its text. To do that we need to explicitly &quot;tell&quot; the button's text
widget to change its content to something new. This is done by sending a message to the widget.</p>
<h3 id="message-routing-strategies"><a class="header" href="#message-routing-strategies">Message routing strategies</a></h3>
<p>Message passing mechanism works in pair with various routing strategies that allows you to define how the message 
will &quot;travel&quot; across the tree of nodes.</p>
<ol>
<li>Bubble - a message starts its way from a widget and goes up on hierarchy until it reaches root node of hierarchy.
Nodes that lies outside that path won't receive the message. This is the most important message routing strategy, that
is used for <strong>every</strong> node by default.</li>
<li>Direct - a message passed directly to every node that are capable to handle it. There is actual routing in this 
case. Direct routing is used in rare cases when you need to catch a message outside its normal &quot;bubble&quot; route.</li>
</ol>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>The engine uses very complex, yet powerful layout system that allows you to build complex user interfaces with 
complex layout. Layout pass has two <em>recursive</em> sub-passes:</p>
<ol>
<li>Measurement - the sub-pass is used to fetch the desired size of each node in hierarchy.</li>
<li>Arrangement - the sub-pass is used to set final position and size of each node in hierarchy.</li>
</ol>
<p>Such split is required because we need to know desired size of each node in hierarchy before we can actually do an
arrangement.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up"><a class="header" href="#setting-up">Setting up</a></h1>
<p>The user interface in the engine is extremely powerful, it allows you to build user interfaces of any complexity
with low effort. To start off we will use the simplest framework:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate rg3d;
</span>
use rg3d::{
    engine::{framework::prelude::*, Engine},
    gui::message::UiMessage
};

struct Game {
    // Empty for now
}

impl GameState for Game {
    fn init(engine: &amp;mut Engine) -&gt; Self
        where
            Self: Sized,
    {
        // Build context will be used in the next chapters.
        let ctx = &amp;mut engine.user_interface.build_ctx();

        //
        // All widgets will be created here in the next chapters.
        //

        Self { }
    }

    fn on_ui_message(&amp;mut self, engine: &amp;mut Engine, message: UiMessage) {
        //
        // Here we'll handle messages from user interface.
        //
    }
}

fn main() {
    Framework::&lt;Game&gt;::new()
        .unwrap()
        .title(&quot;User Interface&quot;)
        .run();
}

</code></pre></pre>
<p>This will be the basis for all next chapters. The most important places marked with respective comments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-rules-1"><a class="header" href="#general-rules-1">General rules</a></h1>
<p>This chapter covers general rules that will help you to write code that will be easy to understand.</p>
<h2 id="fluent-syntax"><a class="header" href="#fluent-syntax">Fluent syntax</a></h2>
<p>Widget builders supports fluent syntax, this means that you can create your widget in series of nested 
call of other widget builders. In code, it looks something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder, image::ImageBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span><span class="boring">fn create_fancy_button(ui: &amp;mut UserInterface, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
</span><span class="boring">let ctx = &amp;mut ui.build_ctx();
</span>ButtonBuilder::new(WidgetBuilder::new())
    .with_back(
        ImageBuilder::new(WidgetBuilder::new())
            .with_texture(into_gui_texture(
                resource_manager.request_texture(&quot;path/to/your/texture&quot;, None),
            ))
            .build(ctx),
    )
    .with_text(&quot;Click me!&quot;)
    .build(ctx)
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>This code snippet creates a button with an image and a text. Actually it creates <strong>three</strong> widgets, that forms 
complex hierarchy. The topmost widget in hierarchy is the <code>Button</code> widget itself, it has two children widgets:
background image and a text. Background image is set explicitly by calling image widget builder with specific 
texture. The text is created implicitly, the button builder creates <code>Text</code> widget for you and attaches it to 
the button. The structure of the button can contain <em>any</em> amount of nodes, for example you can create a button
that contains text with some icon. To do that, replace <code>.with_text(&quot;My Button&quot;)</code> with this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder,
</span><span class="boring">        grid::{Column, GridBuilder, Row},
</span><span class="boring">        image::ImageBuilder,
</span><span class="boring">        text::TextBuilder,
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn create_fancy_button(
</span><span class="boring">    ui: &amp;mut UserInterface,
</span><span class="boring">    resource_manager: ResourceManager,
</span><span class="boring">) -&gt; Handle&lt;UiNode&gt; {
</span><span class="boring">    let ctx = &amp;mut ui.build_ctx();
</span><span class="boring">
</span><span class="boring">    ButtonBuilder::new(WidgetBuilder::new())
</span>        .with_content(
            GridBuilder::new(
                WidgetBuilder::new()
                    .with_child(
                        ImageBuilder::new(WidgetBuilder::new().on_column(0))
                            .with_texture(into_gui_texture(
                                resource_manager.request_texture(&quot;your_icon&quot;, None),
                            ))
                            .build(ctx),
                    )
                    .with_child(
                        TextBuilder::new(WidgetBuilder::new().on_column(1))
                            .with_text(&quot;My Button&quot;)
                            .build(ctx),
                    ),
            )
            .add_row(Row::stretch())
            .add_column(Column::auto())
            .add_column(Column::stretch())
            .build(ctx),
        )
<span class="boring">      .build(ctx)
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Quite often you need to store a handle to a widget in a variable, there is one neat trick to do that preserving
the fluent syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder, image::ImageBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span><span class="boring">fn create_fancy_button(ui: &amp;mut UserInterface, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
</span><span class="boring">let ctx = &amp;mut ui.build_ctx();
</span>let image;
ButtonBuilder::new(WidgetBuilder::new())
    .with_back({
        image = ImageBuilder::new(WidgetBuilder::new())
            .with_texture(into_gui_texture(
                resource_manager.request_texture(&quot;path/to/your/texture&quot;, None),
            ))
            .build(ctx);
        image
    })
    .with_text(&quot;Click me!&quot;)
    .build(ctx)
<span class="boring">}
</span>// image now contains a handle of the Image widget 
<span class="boring">}
</span></code></pre></pre>
<h2 id="should-i-create-a-custom-widget-or-use-composition-of-other-widgets"><a class="header" href="#should-i-create-a-custom-widget-or-use-composition-of-other-widgets">Should I create a custom widget or use composition of other widgets?</a></h2>
<p>The answer depends on the use case, but the general rules here is quite simple: </p>
<ul>
<li>If your widget exist in a single instance, then there is no need to create a custom widget for it.</li>
<li>If you need to create multiple instances of your widget, and each widget will carry some specific data, then you
definitely need a custom widget.</li>
</ul>
<p>Custom widgets have some limitations that could be limiting, one of them is that custom widgets do not have 
access to your code, since they're &quot;living&quot; inside UI and know nothing about the &quot;environment&quot; where they're 
being used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="font-wip"><a class="header" href="#font-wip">Font (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theme"><a class="header" href="#theme">Theme</a></h1>
<p>The engine has an ability to customize the look of widgets, however it is not centralized, and has to be done 
per widget. Check <code>Theme</code> section of each widget.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets-wip"><a class="header" href="#widgets-wip">Widgets (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="button"><a class="header" href="#button">Button</a></h1>
<h2 id="simple-button-with-text"><a class="header" href="#simple-button-with-text">Simple button with text</a></h2>
<p>To create a simple button with text you should do something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{button::ButtonBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_button(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    ButtonBuilder::new(WidgetBuilder::new())
        .with_text(&quot;Click me!&quot;)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="a-button-with-image"><a class="header" href="#a-button-with-image">A button with image</a></h2>
<p>More fancy-looking button with an image as a background could be created using this code snippet:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder, image::ImageBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span>fn create_fancy_button(ui: &amp;mut UserInterface, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();

    ButtonBuilder::new(WidgetBuilder::new())
        .with_back(
            ImageBuilder::new(WidgetBuilder::new())
                .with_texture(into_gui_texture(
                    resource_manager.request_texture(&quot;path/to/your/texture&quot;, None),
                ))
                .build(ctx),
        )
        .with_text(&quot;Click me!&quot;)
        .build(ctx)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-handling"><a class="header" href="#message-handling">Message handling</a></h2>
<p>When clicked, a button sends a <code>ButtonMessage::Click</code> message, you can catch it in your code and do something
useful:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::{framework::GameState, Engine},
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder,
</span><span class="boring">        message::{ButtonMessage, UiMessage, UiMessageData},
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct Game {
</span><span class="boring">    button: Handle&lt;UiNode&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl GameState for Game {
      // ...
<span class="boring">    fn init(engine: &amp;mut Engine) -&gt; Self
</span><span class="boring">        where
</span><span class="boring">            Self: Sized,
</span><span class="boring">    {
</span><span class="boring">        Self {
</span><span class="boring">            button: ButtonBuilder::new(WidgetBuilder::new())
</span><span class="boring">                .with_text(&quot;Click me!&quot;)
</span><span class="boring">                .build(&amp;mut engine.user_interface.build_ctx()),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn on_ui_message(&amp;mut self, engine: &amp;mut Engine, message: UiMessage) {
        if let UiMessageData::Button(ButtonMessage::Click) = message.data() {
            if message.destination() == self.button {
                //
                // Insert your code clicking handling code here.
                //
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="border"><a class="header" href="#border">Border</a></h1>
<p>To create a simple thick border you should do something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{button::ButtonBuilder, widget::WidgetBuilder, border::BorderBuilder, UiNode, Thickness, UserInterface},
</span><span class="boring">};
</span>fn create_border_with_button(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    BorderBuilder::new(WidgetBuilder::new()
            .with_child(
                ButtonBuilder::new(WidgetBuilder::new())
                .with_text(&quot;Click me&quot;)
                .build(&amp;mut ui.build_ctx()),
            )
    )
    .with_stroke_thickness(Thickness {left: 1.0, right: 1.0, top: 1.0, bottom: 1.0})
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>BorderBuilder is a completely static item that only helps to
beautify the widgets around it, it doesnt have many usages.</p>
<p>// FIXME</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas-wip"><a class="header" href="#canvas-wip">Canvas (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="check-box"><a class="header" href="#check-box">Check box</a></h1>
<p>Checkbox is a UI widget that have three states - <code>Checked</code>, <code>Unchecked</code> and <code>Undefined</code>. In most cases it is used
only with two values which fits in <code>bool</code> type. Third, undefined, state is used for specific situations when your
data have such state. </p>
<h2 id="how-it-looks"><a class="header" href="#how-it-looks">How it looks</a></h2>
<p>Checkbox in <code>Checked</code> state:</p>
<p><img src="rg3d/ui/checkbox/./checked.png" alt="Checked" /></p>
<p>Checkbox in <code>Unchecked</code> state:</p>
<p><img src="rg3d/ui/checkbox/./unchecked.png" alt="Unchecked" /></p>
<h2 id="how-to-create-5"><a class="header" href="#how-to-create-5">How to create</a></h2>
<p>To create a checkbox you should do something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{check_box::CheckBoxBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_checkbox(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    CheckBoxBuilder::new(WidgetBuilder::new())
        // A custom value can be set during initialization.
        .checked(Some(true))
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>The above code will create a checkbox without any textual info, but usually checkboxes have some useful info
near them. To create such checkbox, you could use <code>.with_content(..)</code> method which accepts any widget handle.
For checkbox with text, you could use <code>TextBuilder</code> to create textual content, for checkbox with text - use 
<code>ImageBuilder</code>. As already said, you're free to use any widget handle there.</p>
<p>Here's an example of checkbox with textual content.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        check_box::CheckBoxBuilder, text::TextBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_checkbox(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();

    CheckBoxBuilder::new(WidgetBuilder::new())
        // A custom value can be set during initialization.
        .checked(Some(true))
        .with_content(
            TextBuilder::new(WidgetBuilder::new())
                .with_text(&quot;This is a checkbox&quot;)
                .build(ctx),
        )
        .build(ctx)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-handling-1"><a class="header" href="#message-handling-1">Message handling</a></h2>
<p>Checkboxes are not static widget and have multiple states. To handle a message from a checkbox, you need to handle
a <code>CheckBoxMessage::Check</code> message. To do so, you can do something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::{framework::GameState, Engine},
</span><span class="boring">    gui::{
</span><span class="boring">        check_box::CheckBoxBuilder,
</span><span class="boring">        message::{CheckBoxMessage, UiMessage, UiMessageData},
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode,
</span><span class="boring">    },
</span><span class="boring">};
</span>
struct Game {
    checkbox: Handle&lt;UiNode&gt;,
}

impl GameState for Game {
      // ...
    fn init(engine: &amp;mut Engine) -&gt; Self
        where
            Self: Sized,
    {
        Self {
            checkbox: CheckBoxBuilder::new(WidgetBuilder::new())
                .build(&amp;mut engine.user_interface.build_ctx()),
        }
    }

    fn on_ui_message(&amp;mut self, engine: &amp;mut Engine, message: UiMessage) {
        if let UiMessageData::CheckBox(CheckBoxMessage::Check(value)) = message.data() {
            if message.destination() == self.checkbox {
                //
                // Insert your clicking handling code here.
                //
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Keep in mind that checkbox (as any other widget) generates <code>WidgetMessage</code> instances. You can catch them too and
do a custom handling if you need.</p>
<h2 id="theme-1"><a class="header" href="#theme-1">Theme</a></h2>
<p>Checkbox can be fully customized to have any look you want, there are few methods that will help you with 
customization:</p>
<ol>
<li><code>.with_content(..)</code> - sets the content that will be shown near the checkbox. </li>
<li><code>.with_check_mark(..)</code> - sets the widget that will be used as checked icon. </li>
<li><code>.with_uncheck_mark(..)</code> - sets the widget that will be used as unchecked icon.</li>
<li><code>.with_undefined_mark(..)</code> - sets the widget that will be used as undefined icon.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curve-editor-wip"><a class="header" href="#curve-editor-wip">Curve editor (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decorator-wip"><a class="header" href="#decorator-wip">Decorator (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docking-manager-wip"><a class="header" href="#docking-manager-wip">Docking manager (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dropdown-list-wip"><a class="header" href="#dropdown-list-wip">Dropdown list (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expander-wip"><a class="header" href="#expander-wip">Expander (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-browser-wip"><a class="header" href="#file-browser-wip">File browser (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grid-wip"><a class="header" href="#grid-wip">Grid (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-wip"><a class="header" href="#image-wip">Image (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inspector-wip"><a class="header" href="#inspector-wip">Inspector (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-view-wip"><a class="header" href="#list-view-wip">List view (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="menu-wip"><a class="header" href="#menu-wip">Menu (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-box-wip"><a class="header" href="#message-box-wip">Message box (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numeric-field-wip"><a class="header" href="#numeric-field-wip">Numeric field (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="popup-wip"><a class="header" href="#popup-wip">Popup (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="progress-bar-wip"><a class="header" href="#progress-bar-wip">Progress bar (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="range-wip"><a class="header" href="#range-wip">Range (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rect-editor-wip"><a class="header" href="#rect-editor-wip">Rect editor (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-bar-wip"><a class="header" href="#scroll-bar-wip">Scroll bar (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-panel-wip"><a class="header" href="#scroll-panel-wip">Scroll panel (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-viewer-wip"><a class="header" href="#scroll-viewer-wip">Scroll viewer (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-panel-wip"><a class="header" href="#stack-panel-wip">Stack panel (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tab-control-wip"><a class="header" href="#tab-control-wip">Tab control (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<p>Text is a simple widget that allows you to print text on screen. It has various options like word wrapping, text
alignment, and so on.</p>
<h2 id="how-to-create-6"><a class="header" href="#how-to-create-6">How to create</a></h2>
<p>An instance of the Text widget could be created like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{text::TextBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="text-alignment-and-word-wrapping"><a class="header" href="#text-alignment-and-word-wrapping">Text alignment and word wrapping</a></h2>
<p>There are various text alignment options for both vertical and horizontal axes. Typical alignment values are:
<code>Left</code>, <code>Center</code>, <code>Right</code> for horizontal axis, and <code>Top</code>, <code>Center</code>, <code>Bottom</code> for vertical axis. An instance of 
centered text could be created like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        text::TextBuilder, widget::WidgetBuilder, HorizontalAlignment, UiNode, UserInterface,
</span><span class="boring">        VerticalAlignment,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_centered_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_horizontal_text_alignment(HorizontalAlignment::Center)
        .with_vertical_text_alignment(VerticalAlignment::Center)
    .with_text(text)
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>Long text is usually needs to wrap on available bounds, there are three possible options for word wrapping:
<code>NoWrap</code>, <code>Letter</code>, <code>Word</code>. An instance of text with word-based wrapping could be created like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        formatted_text::WrapMode, text::TextBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_text_with_word_wrap(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_wrap(WrapMode::Word)
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="fonts-and-colors"><a class="header" href="#fonts-and-colors">Fonts and colors</a></h2>
<p>To set a color of the text just use <code>.with_foreground(..)</code> of the <code>WidgetBuilder</code> while building the text instance:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{color::Color, pool::Handle},
</span><span class="boring">    gui::{brush::Brush, text::TextBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    //               vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    TextBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED)))
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, text is created with default font, however it is possible to set any custom font:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    gui::{
</span><span class="boring">        text::TextBuilder,
</span><span class="boring">        ttf::{Font, SharedFont},
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn load_font() -&gt; SharedFont {
    // Choose desired character set, default is Basic Latin + Latin Supplement.
    // Character set is a set of ranges with Unicode code points.
    let character_set = Font::default_char_set();

    // Normally `block_on` should be avoided.
    let font = block_on(Font::from_file(
        &quot;path/to/your/font.ttf&quot;,
        24.0,
        character_set,
    ))
    .unwrap();

    SharedFont::new(font)
}

fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_font(load_font())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="font-size"><a class="header" href="#font-size">Font size</a></h3>
<p>There is no way to change font size without changing the entire font used by Text, it is known issue and there is
<a href="https://github.com/rg3dengine/rg3d/issues/74">tracking issue</a> for that.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>There are few message types that Text widget can produce, most common are <code>Text</code>, <code>Wrap</code>, <code>Font</code>, <code>VerticalAlignment</code>,
and <code>HorizontalAlignment</code>. An example of changing text at runtime could be something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        message::{MessageDirection, TextMessage},
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn request_change_text(ui: &amp;UserInterface, text_widget_handle: Handle&lt;UiNode&gt;, text: &amp;str) {
    ui.send_message(TextMessage::text(
        text_widget_handle,
        MessageDirection::ToWidget,
        text.to_owned(),
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>Please keep in mind, that like any other situation when you &quot;changing&quot; something via messages, you should remember
that the change is <strong>not</strong> immediate. The change will be applied on <code>ui.poll_message(..)</code> call somewhere in your
code (or will be done automatically if you're using Framework).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-box-wip"><a class="header" href="#text-box-wip">Text box (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-wip"><a class="header" href="#tree-wip">Tree (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector-image-wip"><a class="header" href="#vector-image-wip">Vector image (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-window"><a class="header" href="#creating-a-window">Creating a Window</a></h1>
<p>To create a window you should do something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{pool::Handle, algebra::Vector2},
</span><span class="boring">    gui::{window::{WindowBuilder, WindowTitle}, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_window(ui: &amp;mut UserInterface) {
    WindowBuilder::new(
        WidgetBuilder::new()
            .with_desired_position(Vector2::new(300.0, 0.0))
            .with_width(300.0),
    )
    .with_content(
<span class="boring">      Handle::NONE
</span>    )
    .with_title(WindowTitle::text(&quot;Window&quot;))
    .can_close(true)
    .can_minimize(true)
    .open(true)
    .can_resize(false)
    .build(&amp;mut ui.build_ctx());
}
<span class="boring">}
</span></code></pre></pre>
<p>Something to point out is the .with_desired_position. Its default 
position is the top-left of the screen. Also the .with_content should 
start with a GridBuilder if you plan to add more then one widget. The
rest is human readable and shouldn't need to be explained.</p>
<p>Window is editable object but can only be affected by UI Messages if
their corresponding variable has been set to true.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrap-panel-wip"><a class="header" href="#wrap-panel-wip">Wrap panel (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="resource-management"><a class="header" href="#resource-management">Resource management</a></h1>
<p>This chapter covers resource management in the engine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-resources"><a class="header" href="#model-resources">Model resources</a></h1>
<h2 id="supported-formats"><a class="header" href="#supported-formats">Supported formats</a></h2>
<p>rg3d supports these file formats for 3D models:</p>
<ul>
<li>FBX</li>
<li>RGS - native scenes format produced by rusty-editor</li>
</ul>
<h2 id="tips-for-blender"><a class="header" href="#tips-for-blender">Tips for Blender</a></h2>
<p>Blender's FBX exporter has exporting scale properties usually set to 100%, this may lead to incorrect scale
of your model in the engine. It will have <code>(100.0, 100.0, 100.0)</code> scale which is very huge. To fix that, set
the scale in the exporter to <code>0.01</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="textures-wip"><a class="header" href="#textures-wip">Textures (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-buffers"><a class="header" href="#sound-buffers">Sound Buffers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>The book offers a set of tutorials of how to write a game of specific genre using the engine. Every tutorial starts
from mild difficulty and keep increasing the difficulty until the end. All tutorials are very well structured and
you shouldn't be able to lost in them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-person-shooter-tutorial"><a class="header" href="#first-person-shooter-tutorial">First-Person Shooter Tutorial</a></h1>
<p>In this tutorial we'll make a 3D shooter - something similar to <a href="https://github.com/mrDIMAS/rusty-shooter">rusty-shooter</a>.
Also, the series should help you to learn basic principles which lies in the foundation of the engine.</p>
<h2 id="rg3d-and-rusty-editor-version"><a class="header" href="#rg3d-and-rusty-editor-version">rg3d and rusty-editor version</a></h2>
<p>rg3d changes rapidly and tutorial's code could not compile with the newest versions of the engine, to prevent that
and keep the code compilable over time the versions of both the engine and the editor are set to specific commits 
in the main repo.</p>
<p><strong>rg3d version</strong>: specific commit (<a href="https://github.com/rg3dengine/rg3d/commit/a3c3d678c361aa72fc44c36f3e37adc20a54f311">5564b6e</a>)<br />
<strong>rusty-editor version</strong>: specific commit (<a href="https://github.com/rg3dengine/rusty-editor/commit/81c942d7bd3e70d3604db803ca987af933d44773">ca0da2e</a>)<br />
<strong>Source code</strong>: <a href="https://github.com/rg3dengine/rg3d-tutorials/">GitHub</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fps-tutorial-part-1---character-controller"><a class="header" href="#fps-tutorial-part-1---character-controller">FPS Tutorial Part 1 - Character Controller.</a></h1>
<p><strong>Source code</strong>: <a href="https://github.com/rg3dengine/rg3d-tutorials/tree/main/tutorial1-character-controller">GitHub</a></p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html#introduction">Introduction</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html#creating-a-window">Creating a window</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html#creating-your-first-scene">Creating your first scene</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html#using-the-scene">Using the scene</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html#character-controller">Character controller</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html#finishing-touch">Finishing touch</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>rg3d is a general purpose 3D engine, it allows creating any kind of 3D game, but today we'll focus on classic 3D shooter.
In this tutorial we'll write a simple character controller. This is what we're aiming for:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/VcN3NUdfg3E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Let's start by creating a new cargo project, make a folder and execute this:</p>
<pre><code class="language-bash">cargo init --bin
</code></pre>
<p>Open Cargo.toml and add <code>rg3d</code> dependency:</p>
<pre><code class="language-toml">[dependencies]
# Use specific version from GitHub, because engine changes rapidly and we must use specific version
# to make sure it compiles.
rg3d = { git = &quot;https://github.com/rg3dengine/rg3d&quot;, rev = &quot;a3c3d678c361aa72fc44c36f3e37adc20a54f311&quot; }
</code></pre>
<h3 id="creating-a-window-1"><a class="header" href="#creating-a-window-1">Creating a window</a></h3>
<p>Great! Now we can start writing the game. Let's start from something very simple - a window and a main loop. Just copy 
and paste this code in the <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate rg3d;
</span>use rg3d::{
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    engine::{
        resource_manager::{MaterialSearchOptions, ResourceManager},
        Engine,
    },
    event::{DeviceEvent, ElementState, Event, VirtualKeyCode, WindowEvent},
    event_loop::{ControlFlow, EventLoop},
    physics3d::{
        rapier::{dynamics::RigidBodyBuilder, geometry::ColliderBuilder},
        RigidBodyHandle,
    },
    resource::texture::TextureWrapMode,
    scene::{
        base::BaseBuilder,
        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
        node::Node,
        transform::TransformBuilder,
        Scene,
    },
    window::WindowBuilder,
};
use std::time;

// Our game logic will be updated at 60 Hz rate.
const TIMESTEP: f32 = 1.0 / 60.0;

struct Game {
    // Empty for now.
}

impl Game {
    pub fn new() -&gt; Self {
        Self {}
    }

    pub fn update(&amp;mut self) {
        // Game logic will be placed here.
    }
}

fn main() {
    // Configure main window first.
    let window_builder = WindowBuilder::new().with_title(&quot;3D Shooter Tutorial&quot;);
    // Create event loop that will be used to &quot;listen&quot; events from the OS.
    let event_loop = EventLoop::new();

    // Finally create an instance of the engine.
    let mut engine = Engine::new(window_builder, &amp;event_loop, false).unwrap();

    // Initialize game instance. It is empty for now.
    let mut game = Game::new();

    // Run the event loop of the main window. which will respond to OS and window events and update
    // engine's state accordingly. Engine lets you to decide which event should be handled,
    // this is a minimal working example of how it should be.
    let clock = time::Instant::now();

    let mut elapsed_time = 0.0;
    event_loop.run(move |event, _, control_flow| {
        match event {
            Event::MainEventsCleared =&gt; {
                // This main game loop - it has fixed time step which means that game
                // code will run at fixed speed even if renderer can't give you desired
                // 60 fps.
                let mut dt = clock.elapsed().as_secs_f32() - elapsed_time;
                while dt &gt;= TIMESTEP {
                    dt -= TIMESTEP;
                    elapsed_time += TIMESTEP;

                    // Run our game's logic.
                    game.update();

                    // Update engine each frame.
                    engine.update(TIMESTEP);
                }

                // Rendering must be explicitly requested and handled after RedrawRequested event is received.
                engine.get_window().request_redraw();
            }
            Event::RedrawRequested(_) =&gt; {
                // Render at max speed - it is not tied to the game code.
                engine.render().unwrap();
            }
            Event::WindowEvent { event, .. } =&gt; match event {
                WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
                WindowEvent::KeyboardInput { input, .. } =&gt; {
                    // Exit game by hitting Escape.
                    if let Some(VirtualKeyCode::Escape) = input.virtual_keycode {
                        *control_flow = ControlFlow::Exit
                    }
                }
			    WindowEvent::Resized(size) =&gt; {
                    // It is very important to handle Resized event from window, because
                    // renderer knows nothing about window size - it must be notified
                    // directly when window size has changed.
                    engine.set_frame_size(size.into()).unwrap();
                }
                _ =&gt; (),
            },
            _ =&gt; *control_flow = ControlFlow::Poll,
        }
    });
}
</code></pre></pre>
<p>Wow! There is lots of code for such a simple task. Fear not, everything here is pretty straightforward, let's dive into
this code and disassemble it line by line. Just skip imports, it's too boring. Let's look at this line:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const TIMESTEP: f32 = 1.0 / 60.0;
<span class="boring">}
</span></code></pre></pre>
<p>Here we define a rate of update for logic of our future game, just sticking to common 60 FPS. Next goes the skeleton of
the game, just a struct with two methods. It will be filled later in this tutorial.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    // Empty for now.
}

impl Game {
    pub fn new() -&gt; Self {
        Self {}
    }

    pub fn update(&amp;mut self) {
        // Game logic will be placed here.
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we at the point where the interesting stuff happens - <code>fn main()</code>. We're starting by creating a window builder:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::window::WindowBuilder;
</span>let window_builder = WindowBuilder::new().with_title(&quot;3D Shooter Tutorial&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The builder will be used later by the engine to create a window. Next we're creating our event loop: </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::event_loop::EventLoop;
</span>let event_loop = EventLoop::new();
<span class="boring">}
</span></code></pre></pre>
<p>The event loop is a &quot;magic&quot; thing that receives events from the operating system and feeds your application, this is a very 
important part which makes the application work. Finally, we're creating an instance of the engine:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new(window_builder, &amp;event_loop, false).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>The first two parameters are the window builder and the event loop, the last one is a boolean flag that is responsible for vertical
synchronization (VSync). In this tutorial we'll have VSync disabled, because it requires specific platform-dependent
extenstions which are not always available and callind <code>.unwrap()</code> might result in panic on some platforms. Next we're 
creating an instance of the game, remember this line, it will be changed soon:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut game = Game::new();
<span class="boring">}
</span></code></pre></pre>
<p>Next we define two variables for the game loop: </p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let clock = time::Instant::now();
let mut elapsed_time = 0.0;
<span class="boring">}
</span></code></pre></pre>
<p>At first, we &quot;remember&quot; the starting point of the game in time. The next variable is used to control the game loop. Finally, we run the
event loop and start checking for events coming from the OS:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>event_loop.run(move |event, _, control_flow| {
    match event {
        ...
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>Let's look at each event separately starting from <code>Event::MainEventsCleared</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::MainEventsCleared =&gt; {
    // This main game loop - it has fixed time step which means that game
    // code will run at fixed speed even if renderer can't give you desired
    // 60 fps.
    let mut dt = clock.elapsed().as_secs_f32() - elapsed_time;
    while dt &gt;= TIMESTEP {
        dt -= TIMESTEP;
        elapsed_time += TIMESTEP;

        // Run our game's logic.
        game.update();

        // Update engine each frame.
        engine.update(TIMESTEP);
    }

    // Rendering must be explicitly requested and handled after RedrawRequested event is received.
    engine.get_window().request_redraw();
}
<span class="boring">}
</span></code></pre></pre>
<p>This is the heart of game loop - it stabilizes update rate of game logic by measuring time from last update call
and performs a various amount of iterations based on an amount of time since last update. This makes the game logic update
rate independent of FPS - it will be always 60 Hz for game logic even if FPS is 10. The <code>while</code> loop contains 
<code>game.update()</code> and <code>engine.update(TIMESTEP)</code> calls to update game's logic and engine internals respectively. After the
loop we're asking the engine to render the next frame. In the next match arm <code>Event::RedrawRequested</code> we're handing our request: </p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::RedrawRequested(_) =&gt; {
    // Render at max speed - it is not tied to the game code.
    engine.render().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see rendering happens in a single line of code. Next we need to handle window events:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::WindowEvent { event, .. } =&gt; match event {
    WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
    WindowEvent::KeyboardInput { input, .. } =&gt; {
        // Exit game by hitting Escape.
        if let Some(VirtualKeyCode::Escape) = input.virtual_keycode {
            *control_flow = ControlFlow::Exit
        }
    }
	WindowEvent::Resized(size) =&gt; {
		// It is very important to handle Resized event from window, because
		// renderer knows nothing about window size - it must be notified
		// directly when window size has changed.
		engine.set_frame_size(size.into()).unwrap();
	}
    _ =&gt; (),
},
<span class="boring">}
</span></code></pre></pre>
<p>Here we're just checking if the player has hit Escape button and exit game if so. Also, when <code>WindowEvent::Resized</code> is 
received, we're notifying renderer about that, so it's render targets will be resized too. The final match arm is for 
every other event, nothing fancy here - just asking engine to continue listening for new events.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>_ =&gt; *control_flow = ControlFlow::Poll,
<span class="boring">}
</span></code></pre></pre>
<p>So far so good. This small piece of code just creates a new window and fills it with black color, now we can start 
writing the game. </p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-window.jpg" alt="Window" /></p>
<p>Let's start by creating a simple scene where we'll test our character controller. This is the time when 
<a href="https://github.com/mrDIMAS/rusty-editor">rusty-editor</a> comes into play - rusty-editor is a native scene editor of the
engine. It is worth mentioning what &quot;scene editor&quot; means: unlike many other engines (Unity, UnrealEngine, etc.),
rusty-editor does <strong>not</strong> allow you to run your game inside it, instead you just edit your scene, save it in the editor and load it in
your game. Being able to run a game inside the editor was a very huge task for one person, and I just chose the 
easiest way. Alright, back to the interesting stuff. Build the editor first using instructions from its
<a href="https://github.com/mrDIMAS/rusty-editor">GitHub page</a> using specific commit stated in the beginning of the article.</p>
<h2 id="creating-your-first-scene"><a class="header" href="#creating-your-first-scene">Creating your first scene</a></h2>
<p>This section is completely optional, if you eager to make the game - just use a 
<a href="rg3d/tutorials/fps/tutorial-1/./data.zip">pre-made scene</a> (download it and unpack in the folder of your game) and go to
the <a href="rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html#using-the-scene">next section</a>. Open rusty-editor, it should look like this:</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-rusty-editor.jpg" alt="rusty-editor" /></p>
<p>It will ask you to choose a working directory.</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-configurator.jpg" alt="configurator" /></p>
<p>The working directory is simply a path to your game's executable, in most cases it will be the root folder of your
project.</p>
<p>Next, click <code>File -&gt; CreateScene</code>. Now you can start modifying your scene. All we need for now is a floor and maybe 
some decorations. To do that, you can either create everything from simple objects (cubes, cones, cylinders,
etc.) or load some assets made in 3D editors (like Blender, 3Ds max, etc.). Here we combine two approaches: floor will 
be just a squashed cube and decorations will be 3D models. Let's start from the floor. Click <code>Create -&gt; Mesh -&gt; Cube</code>, 
select the cube and use Scale tool from the toolbar to squash it to form the floor.</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-floor.jpg" alt="Floor" /></p>
<p>Next we need to add physical body to the floor to not fall through it. This is very simple, click <code>Create -&gt; Physics -&gt; Rigid Body</code>
then right-click on the rigid body in the World Viewer and click <code>Add Trimesh Collider</code>. The last step is to bind the 
floor 3D model with the rigid body, to do that drag'n'drop the rigid body on the floor entry in the World Viewer.</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-floor-body.jpg" alt="Floor Body" /></p>
<p>Ok, good, but it looks awful, let's add some texture to it, to do that, 
<a href="rg3d/tutorials/fps/tutorial-1/./floor.jpg">download floor texture</a>, place it to <code>data/textures</code> and apply it to the floor. 
To do that, use the asset browser: at its left side it shows file system of your project, locate <code>data/textures</code> folder 
and select <code>floor.jpg</code>. Now just drag-n-drop the texture to the floor, this is what you should get.</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-floor-texture.jpg" alt="Floor Texture" /></p>
<p>Now let's add some decorations, to do that <a href="rg3d/tutorials/fps/tutorial-1/./barrel.zip">download 3D model</a> I prepared for
this tutorial and unpack it in <code>data/models</code>. Now go to the <code>data/models</code> in the asset browser and just drag-n-drop the
<code>barrel.FBX</code> to the scene. When you'll release the mouse button after dragging, the editor will ask you where to search 
textures for your model, leave everything as is and click &quot;ok&quot;. You can find more info about import options 
<a href="https://docs.rs/rg3d/0.23.1/rg3d/engine/resource_manager/enum.MaterialSearchOptions.html">here</a>. Now use the Scale and 
Move tools to adjust scale and position of the barrel, it should look like this: </p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-barrel.jpg" alt="Barrel" /></p>
<p>Barrel does not have any rigid body yet, and it won't interact with world. Let's fix this. As usual, click <code>Create -&gt; Physics -&gt; Rigid Body</code> 
then click on the added rigid body and add a cylinder collider by right-click on it and selecting <code>Add Cylinder Collider</code>.
Now select the collider and adjust its height and radius. As a final step drag'n'drop the body on the <code>barrel.FBX</code> scene 
node. Keep in mind that every physical body <strong>must</strong> be assigned to &quot;root&quot; node of an object, in case of barrel it will
be <code>barrel.FBX</code> node. Why so? Physical bodies operate in <strong>global</strong> coordinates, and if you'll assign a body to a child node,
rg3d will apply global coordinates of the body as <strong>local</strong> coordinates of the child node. This will result in a desync of
coordinates of the body and the node. This a common mistake made by editor's users.</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-barrel-body.jpg" alt="Barrel Body" /></p>
<p>Now clone some barrels, to do that select a <code>barrel.FBX</code> in the <code>World Outliner</code>, right-click on the scene preview and
press <code>Ctrl+C</code> to copy the barrel and <code>Ctrl+V</code> to paste. Repeat multiple times.</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-barrels.jpg" alt="Barrel" /></p>
<p>Also add a light source, to do that go to <code>Create -&gt; Light -&gt; Point</code> and adjust its position using the Move tool.</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-light.jpg" alt="Barrel" /></p>
<p>The final step: save your scene in <code>data/models</code>, to do that go to <code>File -&gt; Save</code> and select the folder and type name 
of the scene in the field it should be <code>scene.rgs</code>.</p>
<h2 id="using-the-scene"><a class="header" href="#using-the-scene">Using the scene</a></h2>
<p>Now it's the time to load the scene we've made earlier in the game. This is very simple, all we need to do is to load
scene as resource and create its instance. Change <code>fn new()</code> body to:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn new(engine: &amp;mut GameEngine) -&gt; Self {
    let mut scene = Scene::new();

    // Load a scene resource and create its instance.
    engine
        .resource_manager
        .request_model(&quot;data/models/scene.rgs&quot;, MaterialSearchOptions::UsePathDirectly)
        .await
        .unwrap()
        .instantiate_geometry(&amp;mut scene);

    // Next create a camera, it is our &quot;eyes&quot; in the world.
    // This can also be made in editor, but for educational purpose we'll made it by hand.
    let camera = CameraBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, 1.0, -3.0))
                .build(),
        ),
    )
    .build(&amp;mut scene.graph);

    Self {
        camera,
        scene: engine.scenes.add(scene),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You may have noticed that the <code>Game</code> structure now has two new fields: </p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;, // A handle to the scene
    camera: Handle&lt;Node&gt;, // A handle to the camera
}
<span class="boring">}
</span></code></pre></pre>
<p>These fields are just handles to the &quot;entities&quot; we've created in the <code>Game::new()</code>. Also, change <code>let mut game = Game::new();</code> to this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut game = rg3d::core::futures::executor::block_on(Game::new(&amp;mut engine));
<span class="boring">}
</span></code></pre></pre>
<p>Here we execute async function <code>Game::new()</code> and it creates game's instance with the scene we've made previously.
Run the game and you should see this:</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-scene.jpg" alt="Barrel" /></p>
<p>Cool! Now let's disassemble <code>fn new()</code> line by line. First, we're creating an empty scene:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut scene = Scene::new();
<span class="boring">}
</span></code></pre></pre>
<p>The next few lines are the most interesting:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine
    .resource_manager
    .request_model(&quot;data/models/scene.rgs&quot;, MaterialSearchOptions::UsePathDirectly)
    .await
    .unwrap()
    .instantiate_geometry(&amp;mut scene);
<span class="boring">}
</span></code></pre></pre>
<p>Here we're asking the resource manager to load the scene we've made previously, awaiting while it loads and then instantiating
it on the <code>scene</code>. What does &quot;instantiation&quot; mean? In short, it means that we're creating a copy of a scene and adding the copy
to some other scene, the engine remembers connections between clones and original entities and is capable of restoring data
from resource for the instance. At this point we've successfully instantiated the scene. However, we won't see anything
yet - we need a camera:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = CameraBuilder::new(
    BaseBuilder::new().with_local_transform(
        TransformBuilder::new()
            .with_local_position(Vector3::new(0.0, 1.0, -3.0))
            .build(),
    ),
)
.build(&amp;mut scene.graph);
<span class="boring">}
</span></code></pre></pre>
<p>Camera is our &quot;eyes&quot; in the world, here we're just creating a camera and moving it a bit up and back to be able to see the 
scene. Finally, we're adding the scene to the engine's container for scenes, and it gives us a handle to the scene. Later
we'll use the handle to borrow scene and modify it.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    camera,
    scene: engine.scenes.add(scene),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="character-controller"><a class="header" href="#character-controller">Character controller</a></h2>
<p>We've made a lot of things already, but still can't move in the scene. Let's fix this! We'll start writing the character
controller which will allow us to walk in our scene. Let's start with a chunk of code as usual:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    engine::{
</span><span class="boring">        resource_manager::{MaterialSearchOptions, ResourceManager},
</span><span class="boring">        Engine,
</span><span class="boring">    },
</span><span class="boring">    event::{DeviceEvent, ElementState, Event, VirtualKeyCode, WindowEvent},
</span><span class="boring">    event_loop::{ControlFlow, EventLoop},
</span><span class="boring">    physics3d::{
</span><span class="boring">        rapier::{dynamics::RigidBodyBuilder, geometry::ColliderBuilder},
</span><span class="boring">        RigidBodyHandle,
</span><span class="boring">    },
</span><span class="boring">    resource::texture::TextureWrapMode,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">    window::WindowBuilder,
</span><span class="boring">};
</span><span class="boring">use std::time;
</span>
#[derive(Default)]
struct InputController {
    move_forward: bool,
    move_backward: bool,
    move_left: bool,
    move_right: bool,
    pitch: f32,
    yaw: f32,
}

struct Player {
    pivot: Handle&lt;Node&gt;,
    camera: Handle&lt;Node&gt;,
    rigid_body: RigidBodyHandle,
    controller: InputController,
}

impl Player {
    fn new(scene: &amp;mut Scene) -&gt; Self {
        // Create a pivot and attach a camera to it, move it a bit up to &quot;emulate&quot; head.
        let camera;
        let pivot = BaseBuilder::new()
            .with_children(&amp;[{
                camera = CameraBuilder::new(
                    BaseBuilder::new().with_local_transform(
                        TransformBuilder::new()
                            .with_local_position(Vector3::new(0.0, 0.25, 0.0))
                            .build(),
                    ),
                )
                .build(&amp;mut scene.graph);
                camera
            }])
            .build(&amp;mut scene.graph);

        // Create rigid body, it will be used for interaction with the world.
        let rigid_body_handle = scene.physics.add_body(
            RigidBodyBuilder::new_dynamic()
                .lock_rotations() // We don't want the player to tilt.
                .translation(Vector3::new(0.0, 1.0, -1.0)) // Offset player a bit.
                .build(),
        );

        // Add capsule collider for the rigid body.
        scene.physics.add_collider(
            ColliderBuilder::capsule_y(0.25, 0.2).build(),
            &amp;rigid_body_handle,
        );

        // Bind pivot with rigid body. Scene will automatically sync transform of the pivot
        // with the transform of the rigid body.
        scene.physics_binder.bind(pivot, rigid_body_handle);

        Self {
            pivot,
            camera,
            rigid_body: rigid_body_handle.into(),
            controller: Default::default(),
        }
    }

    fn update(&amp;mut self, scene: &amp;mut Scene) {
        // Set pitch for the camera. These lines responsible for up-down camera rotation.
        scene.graph[self.camera].local_transform_mut().set_rotation(
            UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.controller.pitch.to_radians()),
        );

        // Borrow the pivot from the graph.
        let pivot = &amp;mut scene.graph[self.pivot];

        // Borrow rigid body from physics.
        let body = scene
            .physics
            .bodies
            .get_mut(&amp;self.rigid_body)
            .unwrap();

        // Keep only vertical velocity, and drop horizontal.
        let mut velocity = Vector3::new(0.0, body.linvel().y, 0.0);

        // Change the velocity depending on the keys pressed.
        if self.controller.move_forward {
            // If we moving forward then add &quot;look&quot; vector of the pivot.
            velocity += pivot.look_vector();
        }
        if self.controller.move_backward {
            // If we moving backward then subtract &quot;look&quot; vector of the pivot.
            velocity -= pivot.look_vector();
        }
        if self.controller.move_left {
            // If we moving left then add &quot;side&quot; vector of the pivot.
            velocity += pivot.side_vector();
        }
        if self.controller.move_right {
            // If we moving right then subtract &quot;side&quot; vector of the pivot.
            velocity -= pivot.side_vector();
        }

        // Finally new linear velocity.
        body.set_linvel(velocity, true);

        // Change the rotation of the rigid body according to current yaw. These lines responsible for
        // left-right rotation.
        let mut position = *body.position();
        position.rotation =
            UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), self.controller.yaw.to_radians());
        body.set_position(position, true);
    }

    fn process_input_event(&amp;mut self, event: &amp;Event&lt;()&gt;) {
        match event {
            Event::WindowEvent { event, .. } =&gt; {
                if let WindowEvent::KeyboardInput { input, .. } = event {
                    if let Some(key_code) = input.virtual_keycode {
                        match key_code {
                            VirtualKeyCode::W =&gt; {
                                self.controller.move_forward = input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::S =&gt; {
                                self.controller.move_backward =
                                    input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::A =&gt; {
                                self.controller.move_left = input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::D =&gt; {
                                self.controller.move_right = input.state == ElementState::Pressed;
                            }
                            _ =&gt; (),
                        }
                    }
                }
            }
            Event::DeviceEvent { event, .. } =&gt; {
                if let DeviceEvent::MouseMotion { delta } = event {
                    self.controller.yaw -= delta.0 as f32;

                    self.controller.pitch =
                        (self.controller.pitch + delta.1 as f32).clamp(-90.0, 90.0);
                }
            }
            _ =&gt; (),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is all the code we need for character controller, quite a lot actually, but as usual everything here is pretty
straightforward.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Also we must change Game structure a bit too and the new() code.
struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player, // New
}

impl Game {
    pub async fn new(engine: &amp;mut GameEngine) -&gt; Self {
        let mut scene = Scene::new();

        // Load a scene resource and create its instance.
        engine
            .resource_manager
            .request_model(&quot;data/models/scene.rgs&quot;, MaterialSearchOptions::UsePathDirectly)
            .await
            .unwrap()
            .instantiate_geometry(&amp;mut scene);

        Self {
            player: Player::new(&amp;mut scene), // New
            scene: engine.scenes.add(scene),
        }
    }

    pub fn update(&amp;mut self, engine: &amp;mut Engine) {
        self.player.update(&amp;mut engine.scenes[self.scene]); // New
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We've moved camera creation to <code>Player</code>, because now the camera is attached to the player's body. Also, we must add this line
in the beginning of <code>event_loop.run(...)</code> to let <code>player</code> handle input events:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>game.player.process_input_event(&amp;event);        
<span class="boring">}
</span></code></pre></pre>
<p>So, let's try to understand what happens in this huge chunk of code. Let's start from the <code>InputController</code> struct,
it holds the state of the input for a single frame and rotations of player &quot;parts&quot;. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct InputController {
    move_forward: bool,
    move_backward: bool,
    move_left: bool,
    move_right: bool,
    pitch: f32,
    yaw: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Next goes the <code>Player::new()</code> function. First, we're creating a simple chain of nodes of different kinds in the
<a href="https://en.wikipedia.org/wiki/Scene_graph">scene graph</a>. </p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera;
let pivot = BaseBuilder::new()
    .with_children(&amp;[{
        camera = CameraBuilder::new(
            BaseBuilder::new().with_local_transform(
                TransformBuilder::new()
                    .with_local_position(Vector3::new(0.0, 0.25, 0.0))
                    .build(),
            ),
        )
        .build(&amp;mut scene.graph);
        camera
    }])
    .build(&amp;mut scene.graph);
<span class="boring">}
</span></code></pre></pre>
<p>Basically we're making something like this:</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-graph-example.png" alt="Graph" /></p>
<p>As you can see, the camera is attached to the pivot and has a <strong>relative</strong> position of <code>(0.0, 0.25, 0.0)</code>. So when we'll
move pivot, the camera will move too (and rotate of course). Next we're adding a rigid body with a capsule collider and
link it with the pivot.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create rigid body, it will be used for interaction with the world.
let rigid_body_handle = scene.physics.add_body(
    RigidBodyBuilder::new_dynamic()
        .lock_rotations() // We don't want the player to tilt.
        .translation(Vector3::new(0.0, 1.0, -1.0)) // Offset player a bit.
        .build(),
);

// Add capsule collider for the rigid body.
scene.physics.add_collider(
    ColliderBuilder::capsule_y(0.25, 0.2).build(),
    rigid_body_handle,
);

// Bind pivot with rigid body. Scene will automatically sync transform of the pivot
// with the transform of the rigid body.
scene.physics_binder.bind(pivot, rigid_body_handle);
<span class="boring">}
</span></code></pre></pre>
<p>Comments should clarify what is going on here. Finally, we're creating Player instance and return it:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    pivot,
    camera,
    rigid_body: rigid_body_handle.into(),
    controller: Default::default(),
}
<span class="boring">}
</span></code></pre></pre>
<p>Next goes the <code>fn update(...)</code> function, it is responsible for movement of the player. It starts from these lines:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set pitch for the camera. These lines responsible for up-down camera rotation.
scene.graph[self.camera].local_transform_mut().set_rotation(
    UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.controller.pitch.to_radians()),
);
<span class="boring">}
</span></code></pre></pre>
<p>We're borrowing the camera from the graph (<code>scene.graph[self.camera]</code>) and modifying its <strong>local</strong> rotation, using a 
<a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">quaternion</a> built from an axis, and an angle.
This rotates camera in vertical direction. Let's talk about borrowing in the engine. Almost every object in the 
engine &quot;lives&quot; in generational arenas (pool in rg3d's terminology). Pool is a contiguous chunk of memory, to be
able to &quot;reference&quot; an object in a pool rg3d uses handles. Almost every entity has a single owner - the engine,
so to mutate or read data from an entity your have to borrow it first, like this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Borrow the pivot from the graph.
let pivot = &amp;mut scene.graph[self.pivot];

// Borrow rigid body from physics.
let body = scene
    .physics
    .bodies
    .get_mut(self.rigid_body.into())
    .unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>This piece of code <code>scene.graph[self.pivot]</code> borrows <code>pivot</code> as either mutable or shared, depending on the context (basically
it is just an implementation of Index + IndexMut traits). Once we've borrowed objects, we can modify them. As the next
step we calculate new horizontal speed for the player:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Keep only vertical velocity, and drop horizontal.
let mut velocity = Vector3::new(0.0, body.linvel().y, 0.0);

// Change the velocity depending on the keys pressed.
if self.controller.move_forward {
    // If we moving forward then add &quot;look&quot; vector of the pivot.
    velocity += pivot.look_vector();
}
if self.controller.move_backward {
    // If we moving backward then subtract &quot;look&quot; vector of the pivot.
    velocity -= pivot.look_vector();
}
if self.controller.move_left {
    // If we moving left then add &quot;side&quot; vector of the pivot.
    velocity += pivot.side_vector();
}
if self.controller.move_right {
    // If we moving right then subtract &quot;side&quot; vector of the pivot.
    velocity -= pivot.side_vector();
}

// Finally new linear velocity.
body.set_linvel(velocity, true);
<span class="boring">}
</span></code></pre></pre>
<p>We don't need to modify vertical speed, because it should be controlled by the physics engine. Finally, we're setting
rotation of the rigid body:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Change the rotation of the rigid body according to current yaw. These lines responsible for
// left-right rotation.
let mut position = *body.position();
position.rotation = UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), self.controller.yaw.to_radians());
body.set_position(position, true);
<span class="boring">}
</span></code></pre></pre>
<p>The next piece of code is a bit boring, but still should be addressed - it is input handling. In the <code>process_input_event</code>
we check input events and configure input controller accordingly. Basically we're just checking if W, S, A, D keys were 
pressed or released. In the <code>MouseMotion</code> arm, we're modifying yaw and pitch of the controller according to mouse 
velocity. Nothing fancy, except this line:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.controller.pitch = (self.controller.pitch + delta.1 as f32).clamp(-90.0, 90.0);
<span class="boring">}
</span></code></pre></pre>
<p>Here we're just restricting pitch to [-90; 90] degree range to not let flipping camera upside-down. Now let's run the 
game, you should see something like this and be able to walk and turn the camera.</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-controller.jpg" alt="Controller" /></p>
<h2 id="finishing-touch"><a class="header" href="#finishing-touch">Finishing touch</a></h2>
<p>One more thing before we end the tutorial. Black &quot;void&quot; around us isn't nice, let's add skybox for the camera to improve
that. Skybox is a very simple effect that significantly improves scene quality. To add a skybox, add this code first
somewhere before <code>impl Player</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    engine::{
</span><span class="boring">        resource_manager::{MaterialSearchOptions, ResourceManager},
</span><span class="boring">    },
</span><span class="boring">    resource::texture::TextureWrapMode,
</span><span class="boring">    scene::{
</span><span class="boring">        camera::{SkyBox, SkyBoxBuilder},
</span><span class="boring">    },
</span><span class="boring">};
</span>async fn create_skybox(resource_manager: ResourceManager) -&gt; SkyBox {
    // Load skybox textures in parallel.
    let (front, back, left, right, top, bottom) = rg3d::core::futures::join!(
        resource_manager.request_texture(&quot;data/textures/skybox/front.jpg&quot;, None),
        resource_manager.request_texture(&quot;data/textures/skybox/back.jpg&quot;, None),
        resource_manager.request_texture(&quot;data/textures/skybox/left.jpg&quot;, None),
        resource_manager.request_texture(&quot;data/textures/skybox/right.jpg&quot;, None),
        resource_manager.request_texture(&quot;data/textures/skybox/up.jpg&quot;, None),
        resource_manager.request_texture(&quot;data/textures/skybox/down.jpg&quot;, None)
    );

    // Unwrap everything.
    let skybox = SkyBoxBuilder {
        front: Some(front.unwrap()),
        back: Some(back.unwrap()),
        left: Some(left.unwrap()),
        right: Some(right.unwrap()),
        top: Some(top.unwrap()),
        bottom: Some(bottom.unwrap()),
    }
        .build()
        .unwrap();

    // Set S and T coordinate wrap mode, ClampToEdge will remove any possible seams on edges
    // of the skybox.
    let skybox_texture = skybox.cubemap().unwrap();
    let mut data = skybox_texture.data_ref();
    data.set_s_wrap_mode(TextureWrapMode::ClampToEdge);
    data.set_t_wrap_mode(TextureWrapMode::ClampToEdge);

    skybox
}
<span class="boring">}
</span></code></pre></pre>
<p>Then modify signature of <code>Player::new</code> to </p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn new(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Self
<span class="boring">}
</span></code></pre></pre>
<p>We just added resource manager parameter here, and made the function async, because we'll load a bunch of textures 
in the <code>create_skybox</code> function. Add following line at camera builder (before <code>.build</code>):</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_skybox(create_skybox(resource_manager).await)
<span class="boring">}
</span></code></pre></pre>
<p>Also modify player creation in <code>Game::new</code> to this</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>player: Player::new(&amp;mut scene, engine.resource_manager.clone()).await,
<span class="boring">}
</span></code></pre></pre>
<p>Next, download skybox textures from <a href="rg3d/tutorials/fps/tutorial-1/./skybox.zip">here</a> and extract the archive in 
<code>data/textures</code> (all textures from  the archive must be in <code>data/textures/skybox</code>). Now you can run the game, and you
should see something like this:</p>
<p><img src="rg3d/tutorials/fps/tutorial-1/./tutorial1-skybox.jpg" alt="Controller" /></p>
<p>This was the last step of this tutorial.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this tutorial we've learned how to use the engine and the editor. Created simple character controller and walked on
the scene we've made in the editor. I hope you liked this tutorial, and if so, please consider supporting the project on 
<a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is available on
<a href="https://github.com/mrDIMAS/rg3d-tutorials">GitHub</a>. In the next tutorial we'll start adding weapons.</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/lyj1tq/writing_a_3d_shooter_using_rg3d_game_engine_1/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fps-tutorial-part-2---weapons"><a class="header" href="#fps-tutorial-part-2---weapons">FPS Tutorial Part 2 - Weapons</a></h1>
<p><strong>Source code</strong>: <a href="https://github.com/rg3dengine/rg3d-tutorials/tree/main/tutorial2-character-controller">GitHub</a></p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html#introduction">Introduction</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html#adding-weapons">Adding weapons</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html#game-architecture">Game architecture</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html#recoil">Recoil</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html#impact-effects">Impact effects</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Of course for a shooter game we need weapons and targets to shoot at. In this tutorial we'll add weapons to the game.
For simplicity, we'll add only one weapon, as you'll see later it is pretty easy to add more weapons yourself. This 
is the result we're aiming in the tutorial:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GmVAdBdnqeM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="adding-weapons"><a class="header" href="#adding-weapons">Adding weapons</a></h2>
<p>Add a new module <code>weapon.rs</code> near your <code>main.rs</code> and use it somewhere after other imports:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod weapon;
...
use weapon::Weapon;
<span class="boring">}
</span></code></pre></pre>
<p>Switch to <code>weapon.rs</code> and paste this code into it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span>use rg3d::engine::resource_manager::MaterialSearchOptions;
use rg3d::scene::graph::Graph;
use rg3d::{
    core::{algebra::Vector3, math::Vector3Ext, pool::Handle},
    engine::resource_manager::ResourceManager,
    scene::{node::Node, Scene},
};

pub struct Weapon {
    model: Handle&lt;Node&gt;,
    shot_point: Handle&lt;Node&gt;,
    shot_timer: f32,
}

impl Weapon {
    pub async fn new(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Self {
        // Yeah, you need only few lines of code to load a model of any complexity.
        let model = resource_manager
            .request_model(&quot;data/models/m4.fbx&quot;, MaterialSearchOptions::RecursiveUp)
            .await
            .unwrap()
            .instantiate_geometry(scene);

        let shot_point = scene.graph.find_by_name(model, &quot;Weapon:ShotPoint&quot;);

        Self {
            model,
            shot_point,
            shot_timer: 0.0,
        }
    }

    pub fn model(&amp;self) -&gt; Handle&lt;Node&gt; {
        self.model
    }

    pub fn shot_point(&amp;self) -&gt; Handle&lt;Node&gt; {
        self.shot_point
    }

    pub fn update(&amp;mut self, dt: f32) {
        self.shot_timer = (self.shot_timer - dt).min(0.0);
    }

    pub fn can_shoot(&amp;self) -&gt; bool {
        self.shot_timer &lt;= 0.0
    }

    pub fn shoot(&amp;mut self) {
        self.shot_timer = 1.0;
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>This piece of code just loads a <a href="rg3d/tutorials/fps/tutorial-2/./m4.zip">weapon model</a> and saves an instance handle for 
further use. Also, each weapon should contain a helper node that tells from where it will &quot;emit&quot; bullets, the node 
was added in a 3D editor and has name <code>Weapon:ShotPoint</code>. Weapon implementation has helper methods that provide read-only
access to inner fields (<code>model</code>, <code>shot_point</code>). <code>update</code> method just decreases the timer's value which is used to change
the pace of shooting. You may ask &quot;why <code>shoot</code> method just modifies timer's value and does not create bullets, etc.?&quot; -
please be patient, I will explain this later in <a href="rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html#game-architecture">game architecture</a> section of the tutorial.
OK, now we need to make a point where every weapon will be &quot;mounted&quot; on, go to <code>Player::new</code> and add these lines in 
the <code>CameraBuilder</code> instance:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_children(&amp;[{
	weapon_pivot = BaseBuilder::new()
		.with_local_transform(
			TransformBuilder::new()
				.with_local_position(Vector3::new(-0.1, -0.05, 0.015))
				.build(),
		)
		.build(&amp;mut scene.graph);
	weapon_pivot
}]
<span class="boring">}
</span></code></pre></pre>
<p>What is going on here? We're just adding new child node to the camera and offset it by some vector. Every weapon will
be attached to this pivot. Please keep in mind that the offset given in <strong>local</strong> coordinates, which means that weapon
pivot will move with the camera, but with some offset relative to it. Also, do not forget to add this line after 
<code>let camera;</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let weapon_pivot;
<span class="boring">}
</span></code></pre></pre>
<p>Finally, add the weapon pivot to <code>Self { ... }</code> (and also add <code>weapon_pivot: Handle&lt;Node&gt;</code> to the <code>Player</code> struct):</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    pivot,
    camera,
    weapon_pivot, // &lt;- here
    rigid_body: rigid_body_handle.into(),
    controller: Default::default(),
}
<span class="boring">}
</span></code></pre></pre>
<p>Next we need a container for weapons, let's add it to the <code>Game</code> struct:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player,
    weapons: Pool&lt;Weapon&gt; // Weapons will live in a pool
}
<span class="boring">}
</span></code></pre></pre>
<p>Also do not forget to import <code>Pool</code> from <code>rg3d::core::pool</code> in <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use rg3d::core::pool::{Handle, Pool};
...
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to change <code>Game::new()</code> a bit to add a weapon to the player:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn new(engine: &amp;mut Engine) -&gt; Self {
    let mut scene = Scene::new();

    // Load a scene resource and create its instance.
    engine
        .resource_manager
        .request_model(&quot;data/models/scene.rgs&quot;, MaterialSearchOptions::UsePathDirectly)
        .await
        .unwrap()
        .instantiate_geometry(&amp;mut scene);

    // Create player first.
    let player = Player::new(&amp;mut scene, engine.resource_manager.clone()).await;

    // Create weapon next.
    let weapon = Weapon::new(&amp;mut scene, engine.resource_manager.clone()).await;

    // &quot;Attach&quot; the weapon to the weapon pivot of the player.
    scene.graph.link_nodes(weapon.model(), player.weapon_pivot);

    // Create a container for the weapons.
    let mut weapons = Pool::new();

    // Put the weapon into it.
    weapons.spawn(weapon);

    Self {
        player,
        scene: engine.scenes.add(scene),
        weapons,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>At first, we're loading the scene, next we're creating player as usual. Next we're creating a weapon and attach it to 
the weapon pivot we've made earlier. Finally, we're creating a container for the weapons: we'll use Pool to be able 
to borrow weapon later on when we need. So, let's run the game, and you should see something like this:</p>
<p><img src="rg3d/tutorials/fps/tutorial-2/./weapon.jpg" alt="Weapon" /></p>
<p>Alright, now we have a weapon, but it still can't shoot. Let's fix that. </p>
<h3 id="game-architecture"><a class="header" href="#game-architecture">Game architecture</a></h3>
<p>We at the point now where we need to choose correct approach of interaction between parts of the game. We already have
two kinds of entities: player and weapon. In naive approach to shoot a weapon, you'd pass a reference to a weapon in 
<code>Player::update()</code> and would call something like <code>weapon.shoot()</code>. Most likely that at some point you'll end up
in a situation when you need too much of a context in a single method. This is so-called strong coupling, this is
the thing that disappoints borrow checker too much, and it rejects your code because you're trying to borrow same things
multiple times. So we need a way to change strong coupling to loose coupling. To do that we'll use messages to delay 
execution of some actions that require too much of a context. In general, we'll replace direct function call with a 
message that will be put in a common queue and executed later on one by one at the top of call hierarchy (in 
<code>Game::update</code> in our case). Let's begin by adding a MPSC (Multiple Producer Single Consumer) queue to the <code>Game</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player,
    weapons: Pool&lt;Weapon&gt;,
    receiver: Receiver&lt;Message&gt;, // Single receiver, it cannot be cloned.
    sender: Sender&lt;Message&gt;, // Sender can be cloned and used from various places.
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need a <code>Message</code> enumeration, add <code>message.rs</code> module, import it in <code>main.rs</code> (<code>pub mod message;</code>) and fill it
with the following code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::weapon::Weapon;
use rg3d::core::pool::Handle;

pub enum Message {
    ShootWeapon {
        weapons: Handle&lt;Weapon&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>For now, we have only one message kind - <code>ShootWeapon</code> with a single parameter, a handle of a weapon to shoot. We need
a place to handle messages, <code>Game::update</code> seems to be the most suitable - it is on top of &quot;call hierarchy&quot; and has 
most wide context. Let's change <code>Game::update</code> to this code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, engine: &amp;mut Engine, dt: f32) {
    self.player.update(&amp;mut engine.scenes[self.scene]); 

    // v New code v 
    //
    for weapon in self.weapons.iter_mut() {
        weapon.update(dt);
    }

    // We're using `try_recv` here because we don't want to wait until next message -
    // if the queue is empty just continue to next frame.
    while let Ok(message) = self.receiver.try_recv() {
        match message {
            Message::ShootWeapon { weapon } =&gt; {
                self.shoot_weapon(weapon, engine);
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>So, these first three new lines updating every weapon in the game, for now update of a weapon just updates shooting timer.
As you can see we've added new parameter to the function <code>dt: f32</code>, this is the time span from last frame. Do not forget
to pass this parameter in <code>fn main()</code>: <code>game.update(&amp;mut engine, TIMESTEP);</code>. Finally, at the end of the function we're
handling messages from the queue one by one. As you can see we're handling <code>ShootWeapon</code> message, but there is a 
mysterious line <code>self.shoot_weapon(weapon, engine)</code> which is not yet defined, let's fix that, add these lines to 
<code>impl Game</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn shoot_weapon(&amp;mut self, weapon: Handle&lt;Weapon&gt;, engine: &amp;mut Engine) {
    let weapon = &amp;mut self.weapons[weapon];

    if weapon.can_shoot() {
        weapon.shoot();

        let scene = &amp;mut engine.scenes[self.scene];

        let weapon_model = &amp;scene.graph[weapon.model()];

        // Make a ray that starts at the weapon's position in the world and look toward
        // &quot;look&quot; vector of the weapon.
        let ray = Ray::new(
            scene.graph[weapon.shot_point()].global_position(),
            weapon_model.look_vector().scale(1000.0),
        );

        let mut intersections = Vec::new();

        scene.physics.cast_ray(
            RayCastOptions {
                ray_origin: Point3::from(ray.origin),
                max_len: ray.dir.norm(),
                groups: Default::default(),
                sort_results: true, // We need intersections to be sorted from closest to furthest.
                ray_direction: ray.dir,
            },
            &amp;mut intersections,
        );

        // Ignore intersections with player's capsule.
        let trail_length = if let Some(intersection) = intersections
            .iter()
            .find(|i| i.collider != self.player.collider)
        {
            //
            // TODO: Add code to handle intersections with bots.
            //

            // For now just apply some force at the point of impact.
            let colliders_parent = scene
                .physics
                .colliders
                .get(&amp;intersection.collider)
                .unwrap()
                .parent()
                .unwrap();
            scene
                .physics
                .bodies
                .native_mut(colliders_parent)
                .unwrap()
                .apply_force_at_point(
                    ray.dir.normalize().scale(10.0),
                    intersection.position,
                    true,
                );

            // Trail length will be the length of line between intersection point and ray origin.
            (intersection.position.coords - ray.origin).norm()
        } else {
            // Otherwise trail length will be just the ray length.
            ray.dir.norm()
        };

        create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Wow! Why is there so much code to shoot a weapon!? Actually, this is not all the code - check the last line</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
<span class="boring">}
</span></code></pre></pre>
<p>This is yet another function we must add, it is a standalone helper function that creates a shot trail:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        color::Color,
</span><span class="boring">        parking_lot::Mutex,
</span><span class="boring">        sstorage::ImmutableString,
</span><span class="boring">    },
</span><span class="boring">    material::{Material, PropertyValue},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        mesh::{
</span><span class="boring">            surface::{SurfaceBuilder, SurfaceData},
</span><span class="boring">            MeshBuilder, RenderPath,
</span><span class="boring">        },
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span>use std::sync::Arc;
fn create_shot_trail(
    graph: &amp;mut Graph,
    origin: Vector3&lt;f32&gt;,
    direction: Vector3&lt;f32&gt;,
    trail_length: f32,
) {
    let transform = TransformBuilder::new()
        .with_local_position(origin)
        // Scale the trail in XZ plane to make it thin, and apply `trail_length` scale on Y axis
        // to stretch is out.
        .with_local_scale(Vector3::new(0.0025, 0.0025, trail_length))
        // Rotate the trail along given `direction`
        .with_local_rotation(UnitQuaternion::face_towards(&amp;direction, &amp;Vector3::y()))
        .build();

    // Create unit cylinder with caps that faces toward Z axis.
    let shape = Arc::new(Mutex::new(SurfaceData::make_cylinder(
        6,     // Count of sides
        1.0,   // Radius
        1.0,   // Height
        false, // No caps are needed.
        // Rotate vertical cylinder around X axis to make it face towards Z axis
        &amp;UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), 90.0f32.to_radians()).to_homogeneous(),
    )));

    // Create an instance of standard material for the shot trail.
    let mut material = Material::standard();
    material
        .set_property(
            &amp;ImmutableString::new(&quot;diffuseColor&quot;),
            // Set yellow-ish color.
            PropertyValue::Color(Color::from_rgba(255, 255, 0, 120)),
        )
        .unwrap();

    MeshBuilder::new(
        BaseBuilder::new()
            .with_local_transform(transform)
            // Shot trail should live ~0.25 seconds, after that it will be automatically
            // destroyed.
            .with_lifetime(0.25),
    )
    .with_surfaces(vec![SurfaceBuilder::new(shape)
        .with_material(Arc::new(Mutex::new(material)))
        .build()])
    // Do not cast shadows.
    .with_cast_shadows(false)
    // Make sure to set Forward render path, otherwise the object won't be
    // transparent.
    .with_render_path(RenderPath::Forward)
    .build(graph);
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay... Let's disassemble this heap of code line by line. At first, we're borrowing the weapon by its handle and 
check if it can shoot (if the timer has reached zero), and &quot;shoot&quot; (reset the timer) if so:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let weapon = &amp;mut self.weapons[weapon];

    if weapon.can_shoot() {
        weapon.shoot();
    ...
<span class="boring">}
</span></code></pre></pre>
<p>Next we're using ray casting to find the target we're shooting at:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...

let scene = &amp;mut engine.scenes[self.scene];

let weapon_model = &amp;scene.graph[weapon.model()];

// Make a ray that starts at the weapon's position in the world and look toward
// &quot;look&quot; vector of the weapon.
let ray = Ray::new(
    scene.graph[weapon.shot_point()].global_position(),
    weapon_model.look_vector().scale(1000.0),
);

let mut intersections = Vec::new();

scene.physics.cast_ray(
    RayCastOptions {
        ray_origin: Point3::from(ray.origin),
        max_len: ray.dir.norm(),
        groups: Default::default(),
        sort_results: true, // We need intersections to be sorted from closest to furthest.
        ray_direction: ray.dir,
    },
    &amp;mut intersections,
);

...
<span class="boring">}
</span></code></pre></pre>
<p>To determine the &quot;target&quot;, we're have to make a ray first. It starts from the &quot;shot point&quot; we've attached to the weapon.
Direction of the ray is the &quot;look&quot; vector of the weapon model scaled by some large value which defines a &quot;length&quot; of the
ray. Finally, we're casting the ray. Next we have to check each intersection and find the target:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ignore intersections with player's capsule.
let trail_length = if let Some(intersection) = intersections
    .iter()
    .find(|i| i.collider != self.player.collider)
{
    //
    // TODO: Add code to handle intersections with bots.
    //

    // For now just apply some force at the point of impact.
    let colliders_parent = scene
        .physics
        .colliders
        .get(&amp;intersection.collider)
        .unwrap()
        .parent()
        .unwrap();
    scene
        .physics
        .bodies
        .native_mut(colliders_parent)
        .unwrap()
        .apply_force_at_point(
            ray.dir.normalize().scale(10.0),
            intersection.position,
            true,
        );

    // Trail length will be the length of line between intersection point and ray origin.
    (intersection.position.coords - ray.origin).norm()
} else {
    // Otherwise trail length will be just the ray length.
    ray.dir.norm()
};
<span class="boring">}
</span></code></pre></pre>
<p>First intersection most likely will be player's capsule, because shot point may be inside player's capsule. We're 
filtering such intersection in the first three lines. To do that, we have to remember the handle of player's capsule
in <code>Player</code>: <code>collider: ColliderHandle</code> and fill the field in <code>Player::new</code> like this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add capsule collider for the rigid body.
let collider = scene.physics.add_collider(
    ColliderBuilder::capsule_y(0.25, 0.2).build(),
    rigid_body_handle,
);

...

Self {
    ...
    collider, // &lt;-
    ...
}

<span class="boring">}
</span></code></pre></pre>
<p>Next goes <code>TODO</code> comment, remember this line, it will be replaced when we'll add bots in future tutorial.
Until we have no bots, we should somehow emulate shot impact, to do that we'll just apply some force at the point of
impact. Finally, we're calculating desired shot trail length - it is just distance between point of impact and ray's 
origin. In the <code>else</code> branch we're setting the length to be the length of the ray. Finally, we're creating a shot trail: </p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
<span class="boring">}
</span></code></pre></pre>
<p>Now let's dive into this function. It starts from the definition of local transform of the trail:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let transform = TransformBuilder::new()
    .with_local_position(origin)
    // Scale the trail in XZ plane to make it thin, and apply `trail_length` scale on Y axis
    // to stretch is out.
    .with_local_scale(Vector3::new(0.0025, 0.0025, trail_length))
    // Rotate the trail along given `direction`
    .with_local_rotation(UnitQuaternion::face_towards(&amp;direction, &amp;Vector3::y()))
    .build();
<span class="boring">}
</span></code></pre></pre>
<p>Its purpose is to shrink cylinder in XZ plane and stretch it out on Y axis to the length of the trail. Next we're making
geometry for the cylinder:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let shape = Arc::new(Mutex::new(SurfaceData::make_cylinder(
    6,     // Count of sides
    1.0,   // Radius
    1.0,   // Height
    false, // No caps are needed.
    // Rotate vertical cylinder around X axis to make it face towards Z axis
    &amp;UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), 90.0f32.to_radians()).to_homogeneous(),
)));
<span class="boring">}
</span></code></pre></pre>
<p>Here we're creating unit vertical cylinder, rotate it to make it face towards Z axis. Finally, we're creating mesh node:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create an instance of standard material for the shot trail.
let mut material = Material::standard();
material
    .set_property(
        &amp;ImmutableString::new(&quot;diffuseColor&quot;),
        // Set yellow-ish color.
        PropertyValue::Color(Color::from_rgba(255, 255, 0, 120)),
    )
    .unwrap();

MeshBuilder::new(
    BaseBuilder::new()
        .with_local_transform(transform)
        // Shot trail should live ~0.25 seconds, after that it will be automatically
        // destroyed.
        .with_lifetime(0.25),
)
.with_surfaces(vec![SurfaceBuilder::new(shape)
    .with_material(Arc::new(Mutex::new(material)))
    .build()])
// Do not cast shadows.
.with_cast_shadows(false)
// Make sure to set Forward render path, otherwise the object won't be
// transparent.
.with_render_path(RenderPath::Forward)
.build(graph);
<span class="boring">}
</span></code></pre></pre>
<p>The trail will live just 0.25 seconds, rg3d has built-in functionality for short-living objects, you have to just set 
desired lifetime, and an object will be removed at the time. Also, we don't want the trail to cast shadows, and we want 
the trail to be transparent yellow, to do that we have to change render path of the mesh to <code>Forward</code>. In short, every
mesh by default rendered using <code>Deferred</code> renderer which does not support transparent objects due to technical reasons,
but rg3d has <code>Forward</code> renderer for such objects. Check this <a href="https://www.3dgep.com/forward-plus/">article</a> to learn more 
about Deferred and Forward rendering techniques. Ok, now we have to &quot;teach&quot; player how to shoot. At first, let's add new 
field to <code>InputController</code>: <code>shoot: bool</code>. We'll be changing this flag by left mouse click, to do that let's add these lines
at the end of <code>Event::WindowEvent</code> match arm before <code>_ =&gt; {}</code> in <code>Player::process_input_event</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;WindowEvent::MouseInput { button, state, .. } =&gt; {
    if button == MouseButton::Left {
        self.controller.shoot = state == ElementState::Pressed;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need a way to send messages to the game from the player. We need a new field in <code>Player</code> struct 
<code>sender: Sender&lt;Message&gt;</code>. Also, we must change signature of <code>Player::new()</code> to this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn new(
    scene: &amp;mut Scene,
    resource_manager: ResourceManager,
    sender: Sender&lt;Message&gt;,
) -&gt; Self 
<span class="boring">}
</span></code></pre></pre>
<p>Just pass the <code>sender</code> in the <code>Self { .. }</code> like this: </p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    ...
    sender, // &lt;- Pass sender 
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Player must know about its weapons, let's fix this by adding new field to the <code>Player</code>: <code>weapon: Handle&lt;Weapon&gt;</code>, we'll
fill this field in the <code>Game::new()</code>, not in <code>Player::new()</code> because at the moment of creation of the player there are
no weapons:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...

// Put the weapon into it - this operation moves the weapon in the pool and returns handle.
let weapon = weapons.spawn(weapon);

// &quot;Give&quot; the weapon to the player.
player.weapon = weapon;

...
<span class="boring">}
</span></code></pre></pre>
<p>Finally, at the end of <code>Player::update</code> we will handle the state of the input controller:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.controller.shoot {
    self.sender
        .send(Message::ShootWeapon {
            weapon: self.weapon,
        })
        .unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, at this momemt you should be able to compile the game and as you run it, you should see something like this when
you'll press left mouse button:</p>
<p><img src="rg3d/tutorials/fps/tutorial-2/./shooting.jpg" alt="Weapon" /></p>
<p>Barrels should react to shots as in the video at the beginning of the tutorial. </p>
<h2 id="recoil"><a class="header" href="#recoil">Recoil</a></h2>
<p>Ok, the weapon shoots but looks kinda unnatural, to fix that we need to add a recoil. This is very simple to do, let's 
start by adding these fields in the <code>Weapon</code> struct:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>recoil_offset: Vector3&lt;f32&gt;,
recoil_target_offset: Vector3&lt;f32&gt;,
<span class="boring">}
</span></code></pre></pre>
<p>Initialize these fields with default values (zero vector):</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>recoil_offset: Default::default(),
recoil_target_offset: Default::default(),
<span class="boring">}
</span></code></pre></pre>
<p>First vector is the actual recoil offset that will be applied to the weapon model, second - target recoil value which
first vector will follow. Why do we need two vectors instead just one? The answer is very simple, we need to smoothly
change offset over time, and to do that offset will just &quot;follow&quot; target offset which will give us desired smooth 
movement. Let's add the code responsible for the recoil to the <code>Weapon::update</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Notice new `graph` parameter
pub fn update(&amp;mut self, dt: f32, graph: &amp;mut Graph) {  
    self.shot_timer = (self.shot_timer - dt).max(0.0);
    
    // v New code v
        
    // `follow` method defined in Vector3Ext trait and it just increases or
    // decreases vector's value in order to &quot;follow&quot; the target value with 
    // given speed.
    self.recoil_offset.follow(&amp;self.recoil_target_offset, 0.5);

    // Apply offset to weapon's model.
    graph[self.model]
        .local_transform_mut()
        .set_position(self.recoil_offset);

    // Check if we've reached target recoil offset.
    if self
        .recoil_offset
        .metric_distance(&amp;self.recoil_target_offset)
        &lt; 0.001
    {
        // And if so, reset offset to zero to return weapon at
        // its default position.
        self.recoil_target_offset = Default::default();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>At first, in the first line we force the <code>recoil_offset</code> to follow <code>recoil_target_offset</code> with given speed. Next we're 
applying offset to weapon's model. Finally, we're checking if we've reached target offset and if so, just reset target
offset to return a weapon to its default position. Also we have to slightly modify <code>Weapon::shoot</code> to modify target
offset:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn shoot(&amp;mut self) {
    self.shot_timer = 0.1;

    // Set new offset after each shot.
    self.recoil_target_offset = Vector3::new(0.0, 0.0, -0.025); 
}
<span class="boring">}
</span></code></pre></pre>
<p>The last thing we need to do is to slightly modify code at the <code>Game::update</code> to pass new parameter to <code>Weapon::update</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> pub fn update(&amp;mut self, engine: &amp;mut GameEngine, dt: f32) {
    let scene = &amp;mut engine.scenes[self.scene];

    self.player.update(scene);

    for weapon in self.weapons.iter_mut() {
        weapon.update(dt, &amp;mut scene.graph);
    }
        
    ...
<span class="boring">}
</span></code></pre></pre>
<p>Ok, run the game, and the weapon should feel more natural now. </p>
<h2 id="impact-effects"><a class="header" href="#impact-effects">Impact effects</a></h2>
<p>Shooting have become much better after we've added a recoil, but there is still no impact effects like sparks. Let's fix
that! This is the first time when we'll use particle systems. Let's add this function somewhere in <code>main.rs</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rg3d;
</span><span class="boring">use rg3d::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        color::Color,
</span><span class="boring">        color_gradient::{ColorGradient, GradientPoint},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">        particle_system::{
</span><span class="boring">            emitter::{base::BaseEmitterBuilder, sphere::SphereEmitterBuilder},
</span><span class="boring">            ParticleSystemBuilder,
</span><span class="boring">        },
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>fn create_bullet_impact(
    graph: &amp;mut Graph,
    resource_manager: ResourceManager,
    pos: Vector3&lt;f32&gt;,
    orientation: UnitQuaternion&lt;f32&gt;,
) -&gt; Handle&lt;Node&gt; {
    // Create sphere emitter first.
    let emitter = SphereEmitterBuilder::new(
        BaseEmitterBuilder::new()
            .with_max_particles(200)
            .with_spawn_rate(1000)
            .with_size_modifier_range(-0.01..-0.0125)
            .with_size_range(0.0010..0.025)
            .with_x_velocity_range(-0.01..0.01)
            .with_y_velocity_range(0.017..0.02)
            .with_z_velocity_range(-0.01..0.01)
            .resurrect_particles(false),
    )
    .with_radius(0.01)
    .build();

    // Color gradient will be used to modify color of each particle over its lifetime.
    let color_gradient = {
        let mut gradient = ColorGradient::new();
        gradient.add_point(GradientPoint::new(0.00, Color::from_rgba(255, 255, 0, 0)));
        gradient.add_point(GradientPoint::new(0.05, Color::from_rgba(255, 160, 0, 255)));
        gradient.add_point(GradientPoint::new(0.95, Color::from_rgba(255, 120, 0, 255)));
        gradient.add_point(GradientPoint::new(1.00, Color::from_rgba(255, 60, 0, 0)));
        gradient
    };

    // Create new transform to orient and position particle system.
    let transform = TransformBuilder::new()
        .with_local_position(pos)
        .with_local_rotation(orientation)
        .build();

    // Finally create particle system with limited lifetime.
    ParticleSystemBuilder::new(
        BaseBuilder::new()
            .with_lifetime(1.0)
            .with_local_transform(transform),
    )
    .with_acceleration(Vector3::new(0.0, -10.0, 0.0))
    .with_color_over_lifetime_gradient(color_gradient)
    .with_emitters(vec![emitter])
    // We'll use simple spark texture for each particle.
    .with_texture(resource_manager.request_texture(Path::new(&quot;data/textures/spark.png&quot;), None))
    .build(graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, again a heap of code... As usual, everything here is pretty straightforward. At first, we're creating spherical
emitter - it is a spherical volume that responsible for spawning particles. It has a radius, and a bunch of basic properties
such as spawn rate, maximum amount of particles, initial velocity range, etc. Next we're creating color gradient to make
particles fade over their lifetime. Next, we're creating simple transform that will orient and position particle system 
in world space. Finally, we're creating particle system itself, using pre-made parts. For each particle we'll use simple
<a href="rg3d/tutorials/fps/tutorial-2/./spark.png">spark texture</a>, it should be placed in <code>data/textures</code>. Now we need to find
correct place to create this particle system. It should be placed right after we're applying force to target we've hit 
in <code>Game::shoot_weapon</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add bullet impact effect.
let effect_orientation = if intersection.normal.normalize() == Vector3::y() {
    // Handle singularity when normal of impact point is collinear with Y axis.
    UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), 0.0)
} else {
    UnitQuaternion::face_towards(&amp;intersection.normal, &amp;Vector3::y())
};

create_bullet_impact(
    &amp;mut scene.graph,
    engine.resource_manager.clone(),
    intersection.position.coords,
    effect_orientation,
);
<span class="boring">}
</span></code></pre></pre>
<p>Ok, now run the game, and you should see something like this:</p>
<p><img src="rg3d/tutorials/fps/tutorial-2/./impact.jpg" alt="Weapon" /></p>
<p>One more thing that could be added is bullet shells that should come from a weapon when we're shooting, but I think the
tutorial is already pretty big already, and I'll leave this as a &quot;homework&quot;, but I'll just give some hints of how to do 
this. Make or download a shell model in FBX format, then write a function that will load it via resource manager, 
instantiate it and create a physical body for it (with cylinder collider for example), link a model with a body and call 
this function when shooting a weapon.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>In this tutorial we added weapon to the game, added recoil to make shooting more natural, and added impact effects. I 
hope you liked this tutorial, and if so, please consider supporting the project on
<a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is available on
<a href="https://github.com/mrDIMAS/rg3d-tutorials">GitHub</a>. In the next tutorial we'll add sounds to the game and something
special (let it be a surprise).</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/m2055c/writing_a_3d_shooter_using_rg3d_2_adding_shooting/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fps-tutorial-part-1---bots-and-ai"><a class="header" href="#fps-tutorial-part-1---bots-and-ai">FPS Tutorial Part 1 - Bots and AI</a></h1>
<p><strong>Source code</strong>: <a href="https://github.com/rg3dengine/rg3d-tutorials/tree/main/tutorial3-character-controller">GitHub</a></p>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of contents</a></h2>
<ul>
<li><a href="rg3d/tutorials/fps/tutorial-3/tutorial-part-3.html#introduction">Introduction</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-3/tutorial-part-3.html#bots">Bots</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-3/tutorial-part-3.html#animations">Animations</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-3/tutorial-part-3.html#simple-ai">Simple AI</a></li>
<li><a href="rg3d/tutorials/fps/tutorial-3/tutorial-part-3.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>In the previous tutorial we've added weapons, but we still have no bots to shoot at. Let's fix that! In this tutorial
we'll add bots and a very simple AI. Bots will be a bit dumb, but it will be fixed in future tutorials. This is the
result we're aiming in the tutorial:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dtudhbRBIq0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="bots"><a class="header" href="#bots">Bots</a></h2>
<p>Previous tutorials were children's play in comparison to this, prepare for some advanced stuff. Let's begin by adding
a separate module for bots - add <code>bot.rs</code> and fill it with following code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rg3d::engine::resource_manager::MaterialSearchOptions;
use rg3d::{
    animation::{
        machine::{Machine, Parameter, PoseNode, State, Transition},
        Animation,
    },
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    engine::resource_manager::ResourceManager,
    physics3d::{
        rapier::dynamics::RigidBodyBuilder, rapier::geometry::ColliderBuilder, ColliderHandle,
        RigidBodyHandle,
    },
    resource::model::Model,
    scene::{base::BaseBuilder, node::Node, Scene},
};

pub struct Bot {
    pivot: Handle&lt;Node&gt;,
    rigid_body: RigidBodyHandle,
    collider: ColliderHandle,
}

impl Bot {
    pub async fn new(
        scene: &amp;mut Scene,
        position: Vector3&lt;f32&gt;,
        resource_manager: ResourceManager,
    ) -&gt; Self {
        // Load bot 3D model as usual.
        let model = resource_manager
            .request_model(&quot;data/models/zombie.fbx&quot;, MaterialSearchOptions::RecursiveUp)
            .await
            .unwrap()
            .instantiate_geometry(scene);

        scene.graph[model]
            .local_transform_mut()
            // Move the model a bit down to make sure bot's feet will be on ground.
            .set_position(Vector3::new(0.0, -0.45, 0.0))
            // Scale the model because it is too big.
            .set_scale(Vector3::new(0.0047, 0.0047, 0.0047));

        let pivot = BaseBuilder::new()
            .with_children(&amp;[model])
            .build(&amp;mut scene.graph);

        // Create rigid body, it will be used for interaction with the world.
        let rigid_body = scene.physics.add_body(
            RigidBodyBuilder::new_dynamic()
                .lock_rotations() // We don't want a bot to tilt.
                .translation(position) // Set desired position.
                .build(),
        );

        // Add capsule collider for the rigid body.
        let collider = scene
            .physics
            .add_collider(ColliderBuilder::capsule_y(0.25, 0.2).build(), &amp;rigid_body);

        // Bind pivot with rigid body. Scene will automatically sync transform of the pivot
        // with the transform of the rigid body.
        scene.physics_binder.bind(pivot, rigid_body);

        Self {
            pivot,
            rigid_body,
            collider,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, before we dive into the code, we need to add some more code in <code>main.rs</code>, let's begin by adding a container for
bots in <code>Game</code>: <code>bots: Pool&lt;Bot&gt;,</code>. Next we need to add some more code to <code>Game::new</code> where we'll add a bot instance in
the game. Also, you can add more than one bot at different positions if you want. Do not forget to download bot model
with textures from <a href="rg3d/tutorials/fps/tutorial-3/./zombie.zip">here</a> and unpack <code>fbx</code> file in <code>data/models</code> and other files
(textures), in <code>data/textures</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add some bots.
let mut bots = Pool::new();

bots.spawn(
    Bot::new(
        &amp;mut scene,
        Vector3::new(-1.0, 1.0, -1.0),
        engine.resource_manager.clone(),
    )
    .await,
);

...

Self {
    ...
    bots
}
<span class="boring">}
</span></code></pre></pre>
<p>As usual, let's disassemble the code line-by-line. Creation of bot begins from loading its 3D model in the scene:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let model = resource_manager
    .request_model(&quot;data/models/zombie.fbx&quot;, MaterialSearchOptions::RecursiveUp)
    .await
    .unwrap()
    .instantiate_geometry(scene);
<span class="boring">}
</span></code></pre></pre>
<p>Nothing really new here, loading and instantiation of a 3D model of <em>any</em> complexity is the same as before. Next we have
to slightly modify the model, shift it a bit down and shrink:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>scene.graph[model]
    .local_transform_mut()
    // Move the model a bit down to make sure bot's feet will be on ground.
    .set_position(Vector3::new(0.0, -0.45, 0.0))
    // Scale the model because it is too big.
    .set_scale(Vector3::new(0.0047, 0.0047, 0.0047));
<span class="boring">}
</span></code></pre></pre>
<p>Here we're borrow model in the scene graph, and modify its local transform. Next we're creating pivot for the model:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pivot = BaseBuilder::new()
    .with_children(&amp;[model])
    .build(&amp;mut scene.graph);
<span class="boring">}
</span></code></pre></pre>
<p>We need this pivot because we can't assign rigid body directly to the model, because otherwise we'd lose the ability to
add offset to the model as we want (this happens because rg3d syncs transform of a node with its rigid body). Next we're
creating a rigid body with a capsule collider, attentive reader should notice that next piece of code is the exact copy
of the code from <code>Player::new</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create rigid body, it will be used for interaction with the world.
let rigid_body = scene.physics.add_body(
    RigidBodyBuilder::new_dynamic()
        .lock_rotations() // We don't want a bot to tilt.
        .translation(position) // Set desired position.
        .build(),
);

// Add capsule collider for the rigid body.
let collider = scene
    .physics
    .add_collider(ColliderBuilder::capsule_y(0.25, 0.2).build(), &amp;rigid_body);

// Bind pivot with rigid body. Scene will automatically sync transform of the pivot
// with the transform of the rigid body.
scene.physics_binder.bind(pivot, rigid_body);
<span class="boring">}
</span></code></pre></pre>
<p>You're right, bots will have the same rigid body as the player has. Finally, we're returning bot's instance:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    pivot,
    rigid_body,
    collider,
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, now for the bots instantiation, for simplicity we create a single bot in <code>Game::new</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut bots = Pool::new();

bots.spawn(
    Bot::new(
        &amp;mut scene,
        Vector3::new(-1.0, 1.0, 1.5),
        engine.resource_manager.clone(),
    )
    .await,
);
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, we'll store bots in a pool as many other game entities, this will allow us to borrow bots later on when 
we'll be adding AI. Ok, now run the game, and you should see something like this:</p>
<p><img src="rg3d/tutorials/fps/tutorial-3/./bot.jpg" alt="Weapon" /></p>
<p>Wow... a T-posing bot... Is this some kind of Cyberpunk 2077 reference? This is boring, let's add some animations to 
make it more &quot;alive&quot;.</p>
<h3 id="animations"><a class="header" href="#animations">Animations</a></h3>
<p>Let's start from definition of animation. Animation is a set of tracks, where each track responsible for animation
of a single node and contains key frames placed on a timeline with some transition rules between key frames. Animation
usually changes just position/rotation/scale of a node. When animation is playing it calculates intermediate values for
each parameter using interpolation techniques (linear and spherical interpolation). Animations in general is very simple
and powerful technique, but at many times it still does not enough. If you will just switch multiple animations from one
to one, it will look very bad and unnatural. This is where animation blending machines come into play.</p>
<p><img src="rg3d/tutorials/fps/tutorial-3/./animation.png" alt="Weapon" /></p>
<p>rg3d provides very powerful mechanism for animations - animation blending machines. If you're already familiar with 
Mecanim in Unity game engine or similar thing in Unreal Engine, then you'll probably already understood what will be
in this paragraph. Animation blending machine (ABM) is a state machine that allows you to blend multiple animations
in one and apply it to a set of bones (or nodes in general). ABM is a graph where each node is a state, each state
has a source of animation pose which in its turn may be another subgraph of pose emitting nodes. States connected 
between each other using transition edges which have some parameters like transition time, a rule for transition, etc.
At each moment of time either state or transition can be active. In other words this means that ABM is either
transitioning from a state to state or hold a state. This leads to another fact - ABM cannot jump from a state to state
if they're not connected with transition edge. ABMs in general can be represented like this:</p>
<p><img src="rg3d/tutorials/fps/tutorial-3/./machine.png" alt="Weapon" /></p>
<p>States are marked yellow, animation nodes - blue, animations - green. As you can see there can be multiple transitions
between states, each transition has corresponding <code>Rule</code> parameter which is a simple boolean value which tells a machine
when it is possible to start transition. Each state is supplied with animation node (<code>PlayAnimation</code>, <code>BlendAnimations</code>,
<code>BlendAnimationsByIndex</code>, etc.) which does exactly what the name states. <code>PlayAnimation</code> just plays given animation, 
<code>BlendAnimations</code> - blends multiple animations with different weights into one, BlendAnimationsByIndex - blends multiple
animations as the BlendAnimations, but each animation has transition time, and the node uses an index parameter to switch
between attached animations. Please keep in mind that <code>BlendAnimations</code> node can have various sources of pose, as you can 
see in the picture, it uses two <code>PlayAnimation</code> nodes as source of poses, but nothing keeps you from adding new pose source
which will be yet another <code>BlendAnimations</code>. So everything depends on your needs and ABM just gives you enough flexibility.</p>
<p>Ok, back to the game. Let's create a simple ABM for bots. For simplicity, it will contain only three states - Idle, Walk,
Attack. Put this code somewhere at the end of <code>bot.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple helper method to create a state supplied with PlayAnimation node.
fn create_play_animation_state(
    animation_resource: Model,
    name: &amp;str,
    machine: &amp;mut Machine,
    scene: &amp;mut Scene,
    model: Handle&lt;Node&gt;,
) -&gt; (Handle&lt;Animation&gt;, Handle&lt;State&gt;) {
    // Animations retargetting just makes an instance of animation and binds it to
    // given model using names of bones.
    let animation = *animation_resource
        .retarget_animations(model, scene)
        .get(0)
        .unwrap();
    // Create new PlayAnimation node and add it to machine.
    let node = machine.add_node(PoseNode::make_play_animation(animation));
    // Make a state using the node we've made.
    let state = machine.add_state(State::new(name, node));
    (animation, state)
}

pub struct BotAnimationMachineInput {
    // Whether a bot is walking or not.
    pub walk: bool,
    // Whether a bot is attacking or not.
    pub attack: bool,
}

pub struct BotAnimationMachine {
    machine: Machine,
}

impl BotAnimationMachine {
    // Names of parameters that will be used for transition rules in machine.
    const IDLE_TO_WALK: &amp;'static str = &quot;IdleToWalk&quot;;
    const WALK_TO_IDLE: &amp;'static str = &quot;WalkToIdle&quot;;
    const WALK_TO_ATTACK: &amp;'static str = &quot;WalkToAttack&quot;;
    const IDLE_TO_ATTACK: &amp;'static str = &quot;IdleToAttack&quot;;
    const ATTACK_TO_IDLE: &amp;'static str = &quot;AttackToIdle&quot;;
    const ATTACK_TO_WALK: &amp;'static str = &quot;AttackToWalk&quot;;

    pub async fn new(
        scene: &amp;mut Scene,
        model: Handle&lt;Node&gt;,
        resource_manager: ResourceManager,
    ) -&gt; Self {
        let mut machine = Machine::new();

        // Load animations in parallel.
        let (walk_animation_resource, idle_animation_resource, attack_animation_resource) = rg3d::core::futures::join!(
            resource_manager.request_model(
                &quot;data/animations/zombie_walk.fbx&quot;,
                MaterialSearchOptions::RecursiveUp
            ),
            resource_manager.request_model(
                &quot;data/animations/zombie_idle.fbx&quot;,
                MaterialSearchOptions::RecursiveUp
            ),
            resource_manager.request_model(
                &quot;data/animations/zombie_attack.fbx&quot;,
                MaterialSearchOptions::RecursiveUp
            ),
        );

        // Now create three states with different animations.
        let (_, idle_state) = create_play_animation_state(
            idle_animation_resource.unwrap(),
            &quot;Idle&quot;,
            &amp;mut machine,
            scene,
            model,
        );

        let (walk_animation, walk_state) = create_play_animation_state(
            walk_animation_resource.unwrap(),
            &quot;Walk&quot;,
            &amp;mut machine,
            scene,
            model,
        );

        let (attack_animation, attack_state) = create_play_animation_state(
            attack_animation_resource.unwrap(),
            &quot;Attack&quot;,
            &amp;mut machine,
            scene,
            model,
        );

        // Next, define transitions between states.
        machine.add_transition(Transition::new(
            // A name for debugging.
            &quot;Idle-&gt;Walk&quot;,
            // Source state.
            idle_state,
            // Target state.
            walk_state,
            // Transition time in seconds.
            0.4,
            // A name of transition rule parameter.
            Self::IDLE_TO_WALK,
        ));
        machine.add_transition(Transition::new(
            &quot;Walk-&gt;Idle&quot;,
            walk_state,
            idle_state,
            0.4,
            Self::WALK_TO_IDLE,
        ));
        machine.add_transition(Transition::new(
            &quot;Walk-&gt;Attack&quot;,
            walk_state,
            attack_state,
            0.4,
            Self::WALK_TO_ATTACK,
        ));
        machine.add_transition(Transition::new(
            &quot;Idle-&gt;Attack&quot;,
            idle_state,
            attack_state,
            0.4,
            Self::IDLE_TO_ATTACK,
        ));
        machine.add_transition(Transition::new(
            &quot;Attack-&gt;Idle&quot;,
            attack_state,
            idle_state,
            0.4,
            Self::ATTACK_TO_IDLE,
        ));
        machine.add_transition(Transition::new(
            &quot;Attack-&gt;Walk&quot;,
            attack_state,
            walk_state,
            0.4,
            Self::ATTACK_TO_WALK,
        ));

        // Define entry state.
        machine.set_entry_state(idle_state);

        Self { machine }
    }

    pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, input: BotAnimationMachineInput) {
        self.machine
            // Set transition parameters.
            .set_parameter(Self::WALK_TO_IDLE, Parameter::Rule(!input.walk))
            .set_parameter(Self::IDLE_TO_WALK, Parameter::Rule(input.walk))
            .set_parameter(Self::WALK_TO_ATTACK, Parameter::Rule(input.attack))
            .set_parameter(Self::IDLE_TO_ATTACK, Parameter::Rule(input.attack))
            .set_parameter(Self::ATTACK_TO_IDLE, Parameter::Rule(!input.attack))
            .set_parameter(Self::ATTACK_TO_WALK, Parameter::Rule(!input.attack))
            // Update machine and evaluate final pose.
            .evaluate_pose(&amp;scene.animations, dt)
            // Apply the pose to the graph.
            .apply(&amp;mut scene.graph);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, this might be the biggest heap of code we've ever been dealing with at once. There is lots of stuff happening, 
let's thoroughly &quot;scan&quot; this code. It starts from the simple helper method to create states:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple helper method to create a state supplied with PlayAnimation node.
fn create_play_animation_state(
    animation_resource: Model,
    name: &amp;str,
    machine: &amp;mut Machine,
    scene: &amp;mut Scene,
    model: Handle&lt;Node&gt;,
) -&gt; (Handle&lt;Animation&gt;, Handle&lt;State&gt;) {
    // Animations retargetting just makes an instance of animation and binds it to
    // given model using names of bones.
    let animation = *animation_resource
        .retarget_animations(model, scene)
        .get(0)
        .unwrap();
    // Create new PlayAnimation node and add it to machine.
    let node = machine.add_node(PoseNode::make_play_animation(animation));
    // Make a state using the node we've made.
    let state = machine.add_state(State::new(name, node));
    (animation, state)
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we're using new method of Model resource - <a href="https://github.com/mrDIMAS/rg3d/blob/master/src/resource/model.rs#L110">retarget_animations</a>,
in short, it creates an instance of animation, and binds animations tracks to nodes in given sub graph that starts from
a node given as first parameter. Next we're adding a PlayAnimation node to machine and making a new state node. Now we're
adding a structure with input parameter for ABM:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BotAnimationMachineInput {
    // Whether a bot is walking or not.
    pub walk: bool,
    // Whether a bot is attacking or not.
    pub attack: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>This structure will contain more flags in the future, but now on to <code>BotAnimationMachine::new()</code>. At first, we're creating
new ABM instance, nothing fancy here. Next we're loading animations in parallel: </p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut machine = Machine::new();

// Load animations in parallel.
let (walk_animation_resource, idle_animation_resource, attack_animation_resource) = rg3d::core::futures::join!(
    resource_manager.request_model(
        &quot;data/animations/zombie_walk.fbx&quot;,
        MaterialSearchOptions::RecursiveUp
    ),
    resource_manager.request_model(
        &quot;data/animations/zombie_idle.fbx&quot;,
        MaterialSearchOptions::RecursiveUp
    ),
    resource_manager.request_model(
        &quot;data/animations/zombie_attack.fbx&quot;,
        MaterialSearchOptions::RecursiveUp
    ),
);
<span class="boring">}
</span></code></pre></pre>
<p>As you may have noticed, there is no difference between animation resource and model resource, this is because any 3D
model can have animations. The animations we're loading, contain only bones and key frames for them, but not mesh of a bot.
We simply don't need a mesh, because we've already created the mesh earlier. This separation of animations and mesh is 
very handy, because it saves CPU cycles and disk space. Ok, next we're creating states for ABM:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Now create three states with different animations.
let (_, idle_state) = create_play_animation_state(
    idle_animation_resource.unwrap(),
    &quot;Idle&quot;,
    &amp;mut machine,
    scene,
    model,
);

let (walk_animation, walk_state) = create_play_animation_state(
    walk_animation_resource.unwrap(),
    &quot;Walk&quot;,
    &amp;mut machine,
    scene,
    model,
);

let (attack_animation, attack_state) = create_play_animation_state(
    attack_animation_resource.unwrap(),
    &quot;Attack&quot;,
    &amp;mut machine,
    scene,
    model,
);
<span class="boring">}
</span></code></pre></pre>
<p>These states are those yellow-ish rectangles on diagram up above. As you can see we're creating three states: idle, walk,
attack. Next we need to connect states between each other. </p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Next, define transitions between states.
machine.add_transition(Transition::new(
    // A name for debugging.
    &quot;Idle-&gt;Walk&quot;,
    // Source state.
    idle_state,
    // Target state.
    walk_state,
    // Transition time in seconds.
    0.4,
    // A name of transition rule parameter.
    Self::IDLE_TO_WALK,
));

... // Rest are intentionally omitted 
<span class="boring">}
</span></code></pre></pre>
<p>Ok, comments should clarify what is going on here, but one thing I want to mention specifically. As you may have noticed,
transition is that black arrow on the diagram up above, and it is linked with a parameter. Parameter have a name, and as
you'll see later the name will be used to modify parameters. Finally, we're setting entry state to idle and return 
ABM instance:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define entry state.
machine.set_entry_state(idle_state);

Self { machine }
<span class="boring">}
</span></code></pre></pre>
<p>Now for another important part, we have to &quot;feed&quot; machine with actual parameters for each transition:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, input: BotAnimationMachineInput) {
    self.machine
        // Set transition parameters.
        .set_parameter(Self::WALK_TO_IDLE, Parameter::Rule(!input.walk))
        .set_parameter(Self::IDLE_TO_WALK, Parameter::Rule(input.walk))
        .set_parameter(Self::WALK_TO_ATTACK, Parameter::Rule(input.attack))
        .set_parameter(Self::IDLE_TO_ATTACK, Parameter::Rule(input.attack))
        .set_parameter(Self::ATTACK_TO_IDLE, Parameter::Rule(!input.attack))
        .set_parameter(Self::ATTACK_TO_WALK, Parameter::Rule(!input.attack))
        // Update machine and evaluate final pose.
        .evaluate_pose(&amp;scene.animations, dt)
        // Apply the pose to the graph.
        .apply(&amp;mut scene.graph);
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we're setting each transition rule one by one, then forcing machine to evaluate animation pose and apply it to 
the graph. You may ask how machine knows which nodes (bones) should be affected? Remember what was the definition of 
animation and its tracks? Right, each track knows about the node it affects, animation blending machine just combines
multiple sources of poses into one and animation for same node blends into a final pose and final pose contains animation
for each node that was used in all tracks used in ABM. </p>
<p>Next we need to use the machine we've made. Add a new field to <code>Bot</code>: <code>machine: BotAnimationMachine</code> and initialize it in
&quot;constructor&quot;:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    machine: BotAnimationMachine::new(scene, model, resource_manager).await,
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Next we need to update machine, add following method to <code>impl Bot</code>: </p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32) {
    // For now these are set to false which will force bot to be in idle state.
    let input = BotAnimationMachineInput {
        walk: false,
        attack: false,
    };

    self.machine.update(scene, dt, input);
}
<span class="boring">}
</span></code></pre></pre>
<p>This method will update machine and &quot;feed&quot; it with actual state, for now the state has flags combination that forces
bot to be in idle state. This will be fixed when we'll add simple AI later in this tutorial. Finally, we need to update
each bot we have, go to <code>Game::update</code> and add following lines there (somewhere after update of weapons):</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for bot in self.bots.iter_mut() {
    bot.update(scene, dt);
}
<span class="boring">}
</span></code></pre></pre>
<p>Now run the game, and you should see that bots now is in idle state and animation is playing, it should look like this:</p>
<p><img src="rg3d/tutorials/fps/tutorial-3/./animation.jpg" alt="Weapon" /></p>
<h2 id="simple-ai"><a class="header" href="#simple-ai">Simple AI</a></h2>
<p>Ok, now we have to use ABM we've made at full capacity, to do that we'll write simple AI - bot will just follow player
in a straight line and attack if they're close enough. Let's start by modifying <code>Bot::update</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, target: Vector3&lt;f32&gt;) {
    let attack_distance = 0.6;

    // Simple AI - follow target by a straight line.
    let self_position = scene.graph[self.pivot].global_position();
    let direction = target - self_position;

    // Distance to target.
    let distance = direction.norm();

    if distance != 0.0 &amp;&amp; distance &lt; 1.5 {
        self.follow_target = true;
    }

    if self.follow_target &amp;&amp; distance != 0.0 {
        let rigid_body = scene
            .physics
            .bodies
            .get_mut(&amp;self.rigid_body)
            .unwrap();

        // Make sure bot is facing towards the target.
        let mut position = *rigid_body.position();
        position.rotation = UnitQuaternion::face_towards(
            &amp;Vector3::new(direction.x, 0.0, direction.z),
            &amp;Vector3::y_axis(),
        );
        rigid_body.set_position(position, true);

        // Move only if we're far enough from the target.
        if distance &gt; attack_distance {
            // Normalize direction vector and scale it by movement speed.
            let xz_velocity = direction.scale(1.0 / distance).scale(0.9);

            let new_velocity =
                Vector3::new(xz_velocity.x, rigid_body.linvel().y, xz_velocity.z);

            rigid_body.set_linvel(new_velocity, true);
        }
    }

    // For now these are set to false which will force bot to be in idle state.
    let input = BotAnimationMachineInput {
        walk: self.follow_target &amp;&amp; distance &gt; attack_distance,
        attack: distance &lt; attack_distance,
    };

    self.machine.update(scene, dt, input);
}
<span class="boring">}
</span></code></pre></pre>
<p>Also add a new field to <code>Player</code>: <code>follow_target: bool</code> and initialize it in the constructor: </p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    follow_target: false,
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>So, the AI algorithm is very simple - stand still until a target (player) come closer, once it's close enough, switch
<code>follow_target</code> flag to true and begin to follow the target. To do that, all we have to do is to find a vector between
target and position of a bot, make sure bots is facing towards the target and move it if it is far enough. So let's 
begin digging the code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let attack_distance = 0.6;

// Simple AI - follow target by a straight line.
let self_position = scene.graph[self.pivot].global_position();
let direction = target - self_position;

// Distance to target.
let distance = direction.norm();

if distance != 0.0 &amp;&amp; distance &lt; 1.5 {
    self.follow_target = true;
}
<span class="boring">}
</span></code></pre></pre>
<p>At the beginning we define a melee attack distance, bot will attack target only if it close enough. Next, we're 
building vector to from bot's position to target, calculate distance by taking length of the vector and check if 
we should switch <code>follow_target</code> flag. Next goes the most interesting parts of the AI:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.follow_target &amp;&amp; distance != 0.0 {
    let rigid_body = scene
        .physics
        .bodies
        .get_mut(self.rigid_body.into())
        .unwrap();

    // Make sure bot is facing towards the target.
    let mut position = *rigid_body.position();
    position.rotation = UnitQuaternion::face_towards(
        &amp;Vector3::new(direction.x, 0.0, direction.z),
        &amp;Vector3::y_axis(),
    );
    rigid_body.set_position(position, true);

    ...
<span class="boring">}
</span></code></pre></pre>
<p>Here we just borrow rigid body a bot, and make sure it rotated towards the target. Next we're moving bot if it is
far enough from the target:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    ...

    // Move only if we're far enough from the target.
    if distance &gt; attack_distance {
        // Normalize direction vector and scale it by movement speed.
        let xz_velocity = direction.scale(1.0 / distance).scale(0.9);

        let new_velocity =
            Vector3::new(xz_velocity.x, rigid_body.linvel().y, xz_velocity.z);

        rigid_body.set_linvel(new_velocity, true);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This part is pretty simple too, all we have to do is to check how far the bot is, normalize direction vector, scale it
by movement speed and form new velocity vector using new XZ velocity + current Y velocity of a bot to preserve velocity
added by gravity (otherwise bot would just fly, you can experiment with this part to make flying zombies). One last
thing before we build and run the game, change lines of how we're updating bots to following lines:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let target = scene.graph[self.player.pivot].global_position();

for bot in self.bots.iter_mut() {
    bot.update(scene, dt, target);
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, here we're using player's position as target. In future tutorials we'll improve AI to be able to 
automatically select targets to attack. Also, we'll &quot;teach&quot; bots to use weapons. Now it's the time to build and run 
the game and you should see something like this (something like in the video at the beginning of the tutorial):</p>
<p><img src="rg3d/tutorials/fps/tutorial-3/./ai.jpg" alt="Weapon" /></p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>In this tutorial we've added bots, animations, and a simple AI. This was the most advanced tutorial so far, but I 
promise that this series is far from completion. I hope you liked this tutorial, and if so, please consider supporting 
the project on <a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is 
available on <a href="https://github.com/mrDIMAS/rg3d-tutorials">GitHub</a>.</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/m2ydjc/bots_and_ai_writing_a_3d_shooter_using_rg3d_3/">Reddit</a>, 
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="role-playing-game-tutorial"><a class="header" href="#role-playing-game-tutorial">Role-Playing Game Tutorial</a></h1>
<p>This tutorial starts the series of tutorials about writing a role-playing game in Rust using rg3d game engine. Strangely,
but rg3d has a reputation of an engine for 3D shooters. In this series I'll try to prove that it is a general purpose
game engine.</p>
<h2 id="rg3d-and-rusty-editor-version-1"><a class="header" href="#rg3d-and-rusty-editor-version-1">rg3d and rusty-editor version</a></h2>
<p>rg3d changes rapidly and tutorial's code could not compile with the newest versions of the engine, to prevent that
and keep the code compilable over time the versions of both the engine and the editor are set to specific commits 
in the main repo.</p>
<p><strong>rg3d version</strong>: specific commit (<a href="https://github.com/rg3dengine/rg3d/commit/a3c3d678c361aa72fc44c36f3e37adc20a54f311">5564b6e</a>)<br />
<strong>rusty-editor version</strong>: specific commit (<a href="https://github.com/rg3dengine/rusty-editor/commit/81c942d7bd3e70d3604db803ca987af933d44773">ca0da2e</a>)<br />
<strong>Source code</strong>: <a href="https://github.com/rg3dengine/rg3d-tutorials/">GitHub</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpg-tutorial-part-1---character-controller"><a class="header" href="#rpg-tutorial-part-1---character-controller">RPG Tutorial Part 1 - Character Controller</a></h1>
<p><strong>Source code</strong>: <a href="https://github.com/rg3dengine/rg3d-tutorials/tree/main/rpg-tutorial1-character-controller">GitHub</a></p>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of contents</a></h2>
<ul>
<li><a href="rg3d/tutorials/rpg/tutorial-1/tutorial-part-1.html#introduction">Introduction</a></li>
<li><a href="rg3d/tutorials/rpg/tutorial-1/tutorial-part-1.html#framework">Framework</a></li>
<li><a href="rg3d/tutorials/rpg/tutorial-1/tutorial-part-1.html#assets">Assets</a></li>
<li><a href="rg3d/tutorials/rpg/tutorial-1/tutorial-part-1.html#player-and-camera-controller">Player and camera controller</a></li>
<li><a href="rg3d/tutorials/rpg/tutorial-1/tutorial-part-1.html#camera-movement">Camera movement</a></li>
<li><a href="rg3d/tutorials/rpg/tutorial-1/tutorial-part-1.html#player-locomotion">Player locomotion</a></li>
<li><a href="rg3d/tutorials/rpg/tutorial-1/tutorial-part-1.html#animations">Animations</a></li>
<li><a href="rg3d/tutorials/rpg/tutorial-1/tutorial-part-1.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>In this series of tutorials we will make a game similar to The Elder Scrolls series (but much, much smaller indeed),
we'll have a main character, a simple world with intractable items and a few kind of enemies. I'll show you how to add an inventory,
a quests journal, and the quests itself. This series should have at least 5 tutorials, but this might change. At the end
of the series we'll have a playable RPG which you will be able to use to continue making your own game. It is very ambitious,
but totally doable with the current state of the engine.</p>
<p>Most of the role-playing games (RPGs for short) using 3rd person camera which allows you to see your character entirely.
In this tutorial we'll make something similar. Check the video with final result of the tutorial:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/l2ZbDpoIdqk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>As you can see, at the end of the tutorial we'll be able to walk and explore a small fantasy world. Let's start by creating
a new cargo project:</p>
<p><code>cargo init rpg-tutorial</code></p>
<p>Add <code>rg3d</code> as dependency:</p>
<pre><code class="language-toml">[dependencies]
# Use specific version from GitHub, because engine changes rapidly and we must use specific version
# to make sure it compiles.
rg3d = { git = &quot;https://github.com/rg3dengine/rg3d&quot;, rev = &quot;a3c3d678c361aa72fc44c36f3e37adc20a54f311&quot; }
</code></pre>
<h2 id="framework-1"><a class="header" href="#framework-1">Framework</a></h2>
<p>Now let's create the window and initialize the engine. We'll skip most engine initialization by using new <code>Framework</code> helper
that hides most of the engine initialization and provides unified interface for your games allowing you to focus on
your game code. <code>Framework</code> is not mandatory, you may use the <a href="https://rg3d.rs/tutorials/2021/03/05/tutorial1.html#creating-a-window">previous</a>
variant with manual engine initialization and &quot;opened&quot; main loop.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">// Import everything we need for the tutorial.
use rg3d::{
    core::{color::Color, futures::executor::block_on, pool::Handle},
    engine::framework::{Framework, GameEngine, GameState},
    event::{DeviceEvent, DeviceId, WindowEvent},
    scene::Scene,
};

struct Game {
    // Empty for now.
}

impl GameState for Game {
    fn init(engine: &amp;mut GameEngine) -&gt; Self
    where
        Self: Sized,
    {
        Self {}
    }

    fn on_tick(&amp;mut self, engine: &amp;mut GameEngine, dt: f32) {
        // This method is called at fixed rate of 60 FPS.
        // It will contain all the logic of the game.
    }
}

fn main() {
    Framework::&lt;Game&gt;::new().unwrap().title(&quot;RPG&quot;).run()
}
</code></pre></pre>
<p>It is much easier to initialize the engine now compared to the initialization described in the series of tutorials about
writing a 3D shooter. If you run it, you'll see a window with black background with an &quot;RPG&quot; title.</p>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p>For any kind of game you need a lot of various assets, in our case we need a 3D model for our character, a set of
animations, a level, a set of textures for terrain, trees and bushes, barrels, etc. I prepared all assets as a single
ZIP archive which can be downloaded <a href="rg3d/tutorials/rpg/tutorial-1/./data.zip">here</a>. Once you've downloaded it, unpack it in <code>./data</code> folder.</p>
<h2 id="player-and-camera-controller"><a class="header" href="#player-and-camera-controller">Player and camera controller</a></h2>
<p>Now we can start adding Player to our game. Create a folder <code>player</code> under your <code>src</code> directory and add <code>mod.rs</code> with
following content:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::player::camera::CameraController;

// Import everything we need for the tutorial.
use rg3d::{
    animation::{
        machine::{Machine, Parameter, PoseNode, State, Transition},
        Animation,
    },
    core::{
        algebra::{Isometry3, UnitQuaternion, Vector3},
        pool::Handle,
    },
    engine::{
        resource_manager::{MaterialSearchOptions, ResourceManager},
        ColliderHandle, RigidBodyHandle,
    },
    event::{DeviceEvent, ElementState, KeyboardInput, VirtualKeyCode},
    physics::{
        dynamics::{CoefficientCombineRule, RigidBodyBuilder},
        geometry::ColliderBuilder,
    },
    resource::model::Model,
    scene::{base::BaseBuilder, node::Node, Scene},
};

mod camera;

pub struct Player {
    pivot: Handle&lt;Node&gt;,
    model: Handle&lt;Node&gt;,
    camera_controller: CameraController,
}

impl Player {
    pub async fn new(resource_manager: ResourceManager, scene: &amp;mut Scene) -&gt; Self {
        // Create pivot for our character.
        let pivot = BaseBuilder::new().build(&amp;mut scene.graph);

        // Load paladin 3D model and create its instance in the scene.
        let model = resource_manager
            .request_model(
                &quot;data/models/paladin/paladin.fbx&quot;,
                MaterialSearchOptions::RecursiveUp,
            )
            .await
            .unwrap()
            .instantiate_geometry(scene);

        scene.graph[model]
            .local_transform_mut()
            // Move the model a bit down because its center is at model's feet
            // and we'd get floating model without this offset.
            .set_position(Vector3::new(0.0, -0.75, 0.0))
            // Scale down paladin's model because it is too big. 
            .set_scale(Vector3::new(0.02, 0.02, 0.02));

        // Finally attach the model to the pivot. This will force model to move together with the pivot.
        scene.graph.link_nodes(model, pivot);

        Self {
            pivot,
            model,

            // As a final stage create camera controller.
            camera_controller: CameraController::new(&amp;mut scene.graph, resource_manager).await,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's disassemble this heap of code line by line. At first, we're creating pivot for our character, we'll use it as a
&quot;mounting point&quot; for character's 3D model, also it will have a physical body, but that will be added later in this
tutorial. Next, we're loading paladin 3D model and creating its instance in the scene, we need only geometry without
animations, so we use <code>instantiate_geometry</code> here, animations will be added later in this tutorial. Next we scale the
model a bit, because it is too big. Also, we're moving the model a bit down because its center is at paladin's feet so
when we're attaching the model to the pivot, it will &quot;stay&quot; on the pivot. We want it to stay on ground, so we're moving
it down by height of the model. Finally, we're attaching the model to the pivot, forcing the engine to move
the model together with pivot. In the end we're creating camera controller, it needs its own module, so add <code>camera.rs</code>
module under <code>src/player</code> with following content:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Import everything we need for the tutorial.
use rg3d::{
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    engine::resource_manager::ResourceManager,
    event::DeviceEvent,
    resource::texture::TextureWrapMode,
    scene::{
        base::BaseBuilder,
        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
        graph::Graph,
        node::Node,
        transform::TransformBuilder,
    },
};

async fn create_skybox(resource_manager: ResourceManager) -&gt; SkyBox {
    // Load skybox textures in parallel.
    let (front, back, left, right, top, bottom) = rg3d::core::futures::join!(
        resource_manager.request_texture(&quot;data/textures/skybox/front.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/back.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/left.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/right.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/up.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/down.jpg&quot;)
    );

    // Unwrap everything.
    let skybox = SkyBoxBuilder {
        front: Some(front.unwrap()),
        back: Some(back.unwrap()),
        left: Some(left.unwrap()),
        right: Some(right.unwrap()),
        top: Some(top.unwrap()),
        bottom: Some(bottom.unwrap()),
    }
        .build()
        .unwrap();

    // Set S and T coordinate wrap mode, ClampToEdge will remove any possible seams on edges
    // of the skybox.
    let cubemap = skybox.cubemap();
    let mut data = cubemap.as_ref().unwrap().data_ref();
    data.set_s_wrap_mode(TextureWrapMode::ClampToEdge);
    data.set_t_wrap_mode(TextureWrapMode::ClampToEdge);

    skybox
}

pub struct CameraController {
    pivot: Handle&lt;Node&gt;,
    hinge: Handle&lt;Node&gt;,
    camera: Handle&lt;Node&gt;,
}

impl CameraController {
    pub async fn new(graph: &amp;mut Graph, resource_manager: ResourceManager) -&gt; Self {
        let camera;
        let hinge;
        let pivot = BaseBuilder::new()
            .with_children(&amp;[{
                hinge = BaseBuilder::new()
                    .with_local_transform(
                        TransformBuilder::new()
                            .with_local_position(Vector3::new(0.0, 0.55, 0.0))
                            .build(),
                    )
                    .with_children(&amp;[{
                        camera = CameraBuilder::new(
                            BaseBuilder::new().with_local_transform(
                                TransformBuilder::new()
                                    .with_local_position(Vector3::new(0.0, 0.0, -2.0))
                                    .build(),
                            ),
                        )
                            .with_skybox(create_skybox(resource_manager).await)
                            .build(graph);
                        camera
                    }])
                    .build(graph);
                hinge
            }])
            .build(graph);

        Self {
            pivot,
            hinge,
            camera,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>To understand what this code does let's look closely at this picture:</p>
<p><img src="rg3d/tutorials/rpg/tutorial-1/./camera-layout.png" alt="Camera Layout" /></p>
<p>The pivot is marked yellow here, the hinge - green, and finally the camera is just a trapeze. Lines with arrows shows
how the nodes linked together. As you can see we're attaching the hinge to the pivot and move it up slightly (usually to the
height of the character). Next we're attaching the camera to the hinge and move it back so in default position it will
be behind the character. To understand why we need such layout, let's find out how we need to move and rotate the
camera. We need to rotate the camera around imaginary axis that goes through hinge (&quot;in&quot; the screen on the picture) -
in this layout the camera will always look at character's head and rotate around <strong>local</strong> hinge's X axis. So to do that
we need to rotate the hinge around X axis, not the camera. Here's the picture to help your understanding this better.</p>
<p><img src="rg3d/tutorials/rpg/tutorial-1/./camera-layout-rotated.png" alt="Camera Layout" /></p>
<p>That was just one of the axes, now we need to understand how to rotate the camera around Y axis, but preserving the
rotation around X axis. This is very simple, we have the pivot for that. Remember that each of the nodes (pivot, hinge, camera)
are linked together, so if we'll rotate the pivot around Y axis the hinge will rotate too as well as the camera. Fow
now our camera controller does not have an ability to rotate, we'll add this later in the tutorial.</p>
<p>Now let's load a level where our character will &quot;live&quot;, add <code>level.rs</code> with following content:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rg3d::{
    core::pool::Handle,
    engine::resource_manager::{MaterialSearchOptions, ResourceManager},
    scene::{node::Node, Scene},
};

pub struct Level {
    root: Handle&lt;Node&gt;,
}

impl Level {
    pub async fn new(resource_manager: ResourceManager, scene: &amp;mut Scene) -&gt; Self {
        let root = resource_manager
            .request_model(
                &quot;data/levels/level.rgs&quot;,
                MaterialSearchOptions::UsePathDirectly,
            )
            .await
            .unwrap()
            .instantiate_geometry(scene);

        Self { root }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This small piece of code just loads the scene I made for this tutorial. It has a terrain and some decorations, including
houses, trees, bushes, barrels, etc. The scene was made in the rusty-editor and can be freely edited without any
problems. Just open the scene and modify it as you need.</p>
<p>Now we need to &quot;glue&quot; all the pieces (the player, and the level) together, let's go back to <code>main.rs</code> and change it to
the following code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
use crate::{level::Level, player::Player};
use rg3d::{
    core::{color::Color, futures::executor::block_on, pool::Handle},
    engine::framework::{Framework, GameEngine, GameState},
    event::{DeviceEvent, DeviceId, WindowEvent},
    scene::Scene,
};

mod level;
mod player;

struct Game {
    scene: Handle&lt;Scene&gt;,
    level: Level,
    player: Player,
}

impl GameState for Game {
    fn init(engine: &amp;mut GameEngine) -&gt; Self
    where
        Self: Sized,
    {
        let mut scene = Scene::new();

        scene.ambient_lighting_color = Color::opaque(150, 150, 150);

        let player = block_on(Player::new(engine.resource_manager.clone(), &amp;mut scene));

        Self {
            player,
            level: block_on(Level::new(engine.resource_manager.clone(), &amp;mut scene)),
            scene: engine.scenes.add(scene),
        }
    }

    fn on_tick(&amp;mut self, engine: &amp;mut GameEngine, dt: f32) {
        // This method is called at fixed rate of 60 FPS.
        // It will contain all the logic of the game.
    }
}

fn main() {
    Framework::&lt;Game&gt;::new().unwrap().title(&quot;RPG&quot;).run()
}
</code></pre></pre>
<p>As you can see, everything is pretty straightforward: at first we're creating a new scene, set its ambient lighting to
&quot;daylight&quot;, next we're creating the player and the level. Finally, we're adding the scene to the engine and now if you
run the game you should see something like this:</p>
<p><img src="rg3d/tutorials/rpg/tutorial-1/./scene.jpg" alt="Scene" /></p>
<p>For now everything is static, let's fix that by adding the ability to move the character and rotate the camera.</p>
<h2 id="camera-movement"><a class="header" href="#camera-movement">Camera movement</a></h2>
<p>Let's start from the camera movement and rotation. We need two new fields in the <code>CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An angle around local Y axis of the pivot.
yaw: f32,
// An angle around local X axis of the hinge.
pitch: f32,
<span class="boring">}
</span></code></pre></pre>
<p>Do not forget to initialize them with zeros:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    ...,
    yaw: 0.0,
    pitch: 0.0,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to handle device events coming from the OS to rotate the camera. Add following method to the <code>impl CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handle_device_event(&amp;mut self, device_event: &amp;DeviceEvent) {
    if let DeviceEvent::MouseMotion { delta } = device_event {
        const MOUSE_SENSITIVITY: f32 = 0.015;

        self.yaw -= (delta.0 as f32) * MOUSE_SENSITIVITY;
        self.pitch = (self.pitch + (delta.1 as f32) * MOUSE_SENSITIVITY)
            // Limit vertical angle to [-90; 90] degrees range
            .max(-90.0f32.to_radians())
            .min(90.0f32.to_radians());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this method we use only <code>MouseMotion</code> events, because CameraController does not move - it can only rotate. The method
is pretty straightforward. We're changing yaw and pitch using mouse offsets in two axes. X axis changes yaw, Y axis changes
pitch. Pitch should be limited in specific range to prevent camera to rotate 360 degrees around object, we need angle
to be in <code>[-90; 90]</code> range.</p>
<p>Once we've changed yaw and pitch, we need to apply rotations to the hinge and the camera. To do that, we need to add
a new method to the <code>impl CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, graph: &amp;mut Graph) {
    // Apply rotation to the pivot.
    graph[self.pivot]
        .local_transform_mut()
        .set_rotation(UnitQuaternion::from_axis_angle(
            &amp;Vector3::y_axis(),
            self.yaw,
        ));

    // Apply rotation to the hinge.
    graph[self.hinge]
        .local_transform_mut()
        .set_rotation(UnitQuaternion::from_axis_angle(
            &amp;Vector3::x_axis(),
            self.pitch,
        ));
}
<span class="boring">}
</span></code></pre></pre>
<p>It is a very simple method, it borrows nodes, and applies rotations around specific axes. Now we need to call those two
methods from somewhere. The most suitable place is <code>impl Player</code>, because <code>Player</code> owns an instance of <code>CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handle_device_event(&amp;mut self, device_event: &amp;DeviceEvent) {
    self.camera_controller.handle_device_event(device_event)
}

pub fn update(&amp;mut self, scene: &amp;mut Scene) {
    self.camera_controller.update(&amp;mut scene.graph);
}
<span class="boring">}
</span></code></pre></pre>
<p>For now both methods are just proxies, but it will be changed pretty soon. Now we need to call the proxies, but from where?
The most suitable place is <code>on_tick</code> and <code>on_device_event</code> of the <code>GameState</code> trait implementation for our <code>Game</code> structure:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_tick(&amp;mut self, engine: &amp;mut GameEngine, dt: f32) {
    let scene = &amp;mut engine.scenes[self.scene];

    self.player.update(scene);
}

fn on_device_event(
    &amp;mut self,
    _engine: &amp;mut GameEngine,
    _device_id: DeviceId,
    event: DeviceEvent,
) {
    self.player.handle_device_event(&amp;event);
}
<span class="boring">}
</span></code></pre></pre>
<p>Now you can run the game, and the camera should rotate when you're moving your mouse. Now it's the time to add an ability
to walk for our character.</p>
<h2 id="player-locomotion"><a class="header" href="#player-locomotion">Player locomotion</a></h2>
<p>Our player still can't move, in this section we'll fix it. Player's movement for third person camera differs from the
movement of first person. For the third person camera we must move the player either where the camera looks or according
to pressed keys on the keyboard. Let's start by adding input controller, it will hold info about needed movement:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct InputController {
    walk_forward: bool,
    walk_backward: bool,
    walk_left: bool,
    walk_right: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>Add new field to the <code>Player</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>input_controller: InputController,
<span class="boring">}
</span></code></pre></pre>
<p>And initialize it with <code>Default::default</code> in the <code>Player::new</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    ...,
    input_controller: Default::default(),
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to change the state of the input controller, to do that we'll use keyboard events. Add following method to
the <code>impl Player</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handle_key_event(&amp;mut self, key: &amp;KeyboardInput) {
    if let Some(key_code) = key.virtual_keycode {
        match key_code {
            VirtualKeyCode::W =&gt; {
                self.input_controller.walk_forward = key.state == ElementState::Pressed
            }
            VirtualKeyCode::S =&gt; {
                self.input_controller.walk_backward = key.state == ElementState::Pressed
            }
            VirtualKeyCode::A =&gt; {
                self.input_controller.walk_left = key.state == ElementState::Pressed
            }
            VirtualKeyCode::D =&gt; {
                self.input_controller.walk_right = key.state == ElementState::Pressed
            }
            _ =&gt; (),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to call this method, we'll do it from <code>on_window_event</code> in the <code>GameState</code> trait implementation for our
<code>Game</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_window_event(&amp;mut self, _engine: &amp;mut GameEngine, event: WindowEvent) {
    match event {
        WindowEvent::KeyboardInput { input, .. } =&gt; {
            self.player.handle_key_event(&amp;input);
        }
        _ =&gt; (),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, now we have input controller functioning. Now we can start adding movement logic to the player. Let's start by adding
a physical body to the player. We'll use a capsule rigid body with locked rotations for that. Add these lines somewhere
in <code>Player::new</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create new rigid body and offset it a bit to prevent falling through the ground.
let body = scene.physics.add_body(
    RigidBodyBuilder::new_dynamic()
        .position(Isometry3::translation(0.0, 2.0, 0.0))
        .build(),
);

// Create capsule collider with friction disabled. We need to disable friction because linear
// velocity will be set manually, but the physics engine will reduce it using friction so it
// won't let us to set linear velocity precisely.
let capsule = ColliderBuilder::capsule_y(0.55, 0.25)
    .friction_combine_rule(CoefficientCombineRule::Min)
    .friction(0.0)
    .build();
let collider = scene.physics.add_collider(capsule, &amp;body);

// Finally bind the pivot with the body.
scene.physics_binder.bind(pivot, body);
<span class="boring">}
</span></code></pre></pre>
<p>Now, once our character has physical body, we can move it. Add these lines to the end of <code>Player::update</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pivot = &amp;scene.graph[self.pivot];

let look_vector = pivot
    .look_vector()
    .try_normalize(f32::EPSILON)
    .unwrap_or(Vector3::z());

let side_vector = pivot
    .side_vector()
    .try_normalize(f32::EPSILON)
    .unwrap_or(Vector3::x());

let position = **pivot.local_transform().position();

let mut velocity = Vector3::default();

if self.input_controller.walk_right {
    velocity -= side_vector;
}
if self.input_controller.walk_left {
    velocity += side_vector;
}
if self.input_controller.walk_forward {
    velocity += look_vector;
}
if self.input_controller.walk_backward {
    velocity -= look_vector;
}

let speed = 1.35 * dt;
let velocity = velocity
    .try_normalize(f32::EPSILON)
    .and_then(|v| Some(v.scale(speed)))
    .unwrap_or(Vector3::default());

let body = scene.physics.bodies.get_mut(&amp;self.body).unwrap();

// Apply linear velocity.
body.set_linvel(
    Vector3::new(velocity.x / dt, body.linvel().y, velocity.z / dt),
    true,
);

// Lock any angular movement of the player's body.
body.set_angvel(Default::default(), true);

let is_moving = velocity.norm_squared() &gt; 0.0;
if is_moving {
    // Since we have free camera while not moving, we have to sync rotation of pivot
    // with rotation of camera so character will start moving in look direction.
    let mut current_position = *body.position();
    current_position.rotation =
        UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), self.camera_controller.yaw);
    body.set_position(current_position, true);

    // Apply additional rotation to model - it will turn in front of walking direction.
    let angle: f32 = if self.input_controller.walk_left {
        if self.input_controller.walk_forward {
            45.0
        } else if self.input_controller.walk_backward {
            135.0
        } else {
            90.0
        }
    } else if self.input_controller.walk_right {
        if self.input_controller.walk_forward {
            -45.0
        } else if self.input_controller.walk_backward {
            -135.0
        } else {
            -90.0
        }
    } else if self.input_controller.walk_backward {
        180.0
    } else {
        0.0
    };

    scene.graph[self.model]
        .local_transform_mut()
        .set_rotation(UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), angle.to_radians()));
}

// Sync camera controller position with player's position.
scene.graph[self.camera_controller.pivot]
    .local_transform_mut()
    .set_position(position + velocity);
<span class="boring">}
</span></code></pre></pre>
<p>There is lots of code, let's thoroughly go through. At first, we're getting two vectors from the pivot: X and Z axes of
the global transform of the pivot. We'll use them to move the character. Next we're using the state of the input
controller to form a new velocity vector. Then we're normalizing velocity vector and multiply it with desired speed of
movement. Normalization is needed to make the vector unit length to prevent speed variations in various directions. Next
we're applying the velocity to the rigid body, also we're locking any angular movement to prevent player's capsule
from tilting.</p>
<p>If the player is not moving, we're not syncing its rotation with camera's rotation - this allows us to look at the
character from any side while not moving. However, if the player is moving, we must sync its rotation with the rotation
of the camera controller. If we'd do this straightforward (by just syncing rotations) it would look very unnatural,
especially in case of side movements. To fix this we have this large chain of <code>if..else</code> that selects appropriate
additional rotation for the player's model. This rotation allows us, for example, look forward and move the character
backwards.</p>
<p>As the final step we're syncing position of the camera controller with the position of the pivot. Now if you run the game
you'll be able to walk around using <code>[W][S][A][D]</code> keys. However, it looks very ugly - the character's model is in T-pose,
let's fix this.</p>
<h2 id="animations-1"><a class="header" href="#animations-1">Animations</a></h2>
<p>At this point our character can move, and we can rotate the camera around it, but the character is still in T-pose and
does not have any animation. In this section we'll animate it. To keep this tutorial at reasonable length, we'll
add just an idle and walk animations and smooth transitions between them. Add following code at the end of <code>player.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// Simple helper method to create a state supplied with PlayAnimation node.
fn create_play_animation_state(
    animation_resource: Model,
    name: &amp;str,
    machine: &amp;mut Machine,
    scene: &amp;mut Scene,
    model: Handle&lt;Node&gt;,
) -&gt; (Handle&lt;Animation&gt;, Handle&lt;State&gt;) {
    // Animations retargetting just makes an instance of animation and binds it to
    // given model using names of bones.
    let animation = *animation_resource
        .retarget_animations(model, scene)
        .get(0)
        .unwrap();
    // Create new PlayAnimation node and add it to machine.
    let node = machine.add_node(PoseNode::make_play_animation(animation));
    // Make a state using the node we've made.
    let state = machine.add_state(State::new(name, node));
    (animation, state)
}

pub struct AnimationMachineInput {
    // Whether a bot is walking or not.
    pub walk: bool,
}

pub struct AnimationMachine {
    machine: Machine,
}

impl AnimationMachine {
    // Names of parameters that will be used for transition rules in machine.
    const IDLE_TO_WALK: &amp;'static str = &quot;IdleToWalk&quot;;
    const WALK_TO_IDLE: &amp;'static str = &quot;WalkToIdle&quot;;

    pub async fn new(
        scene: &amp;mut Scene,
        model: Handle&lt;Node&gt;,
        resource_manager: ResourceManager,
    ) -&gt; Self {
        let mut machine = Machine::new();

        // Load animations in parallel.
        let (walk_animation_resource, idle_animation_resource) = rg3d::core::futures::join!(
            resource_manager.request_model(
                &quot;data/models/paladin/walk.fbx&quot;,
                MaterialSearchOptions::RecursiveUp
            ),
            resource_manager.request_model(
                &quot;data/models/paladin/idle.fbx&quot;,
                MaterialSearchOptions::RecursiveUp
            ),
        );

        // Now create two states with different animations.
        let (_, idle_state) = create_play_animation_state(
            idle_animation_resource.unwrap(),
            &quot;Idle&quot;,
            &amp;mut machine,
            scene,
            model,
        );

        let (walk_animation, walk_state) = create_play_animation_state(
            walk_animation_resource.unwrap(),
            &quot;Walk&quot;,
            &amp;mut machine,
            scene,
            model,
        );

        // Next, define transitions between states.
        machine.add_transition(Transition::new(
            // A name for debugging.
            &quot;Idle-&gt;Walk&quot;,
            // Source state.
            idle_state,
            // Target state.
            walk_state,
            // Transition time in seconds.
            0.4,
            // A name of transition rule parameter.
            Self::IDLE_TO_WALK,
        ));
        machine.add_transition(Transition::new(
            &quot;Walk-&gt;Idle&quot;,
            walk_state,
            idle_state,
            0.4,
            Self::WALK_TO_IDLE,
        ));

        // Define entry state.
        machine.set_entry_state(idle_state);

        Self { machine }
    }

    pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, input: AnimationMachineInput) {
        self.machine
            // Set transition parameters.
            .set_parameter(Self::WALK_TO_IDLE, Parameter::Rule(!input.walk))
            .set_parameter(Self::IDLE_TO_WALK, Parameter::Rule(input.walk))
            // Update machine and evaluate final pose.
            .evaluate_pose(&amp;scene.animations, dt)
            // Apply the pose to the graph.
            .apply(&amp;mut scene.graph);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is a simple animation blending machine, for more info check
<a href="https://rg3d.rs/tutorials/2021/03/11/tutorial3.html#animations">&quot;Animations&quot; section of &quot;Writing a 3D shooter using rg3d #3&quot;</a>
tutorial, it has detailed explanation how animation blending machines work. In short, here we're loading two animations,
and create two transitions between them and then applying final pose to the character.</p>
<p>Now we need to create an instance of the <code>AnimationMachine</code>, add a field to the <code>Player</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...,
animation_machine: AnimationMachine,
<span class="boring">}
</span></code></pre></pre>
<p>And initialize it in the <code>Player::new</code>, before <code>camera_controller</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...,
animation_machine: AnimationMachine::new(scene, model, resource_manager.clone()).await,
...
<span class="boring">}
</span></code></pre></pre>
<p>The last thing we need to do is to update animation machine each frame, we'll do this in <code>Player::update</code>, at the end
of the method:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.animation_machine
        .update(scene, dt, AnimationMachineInput { walk: is_moving });
<span class="boring">}
</span></code></pre></pre>
<p>Now if you run the game, you should see the character idling if not moving, and it should play &quot;walking&quot; animation if
moving. That's it for this tutorial, in the next tutorial we'll &quot;teach&quot; the character to use swords.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>In this tutorial we've learned how create a walking character. Created simple character controller and walked on
the scene. I hope you liked this tutorial, and if so, please consider supporting the project on
<a href="https://patreon.com/mrdimas">Patreon</a> or do a one-time donation via <a href="https://www.buymeacoffee.com/mrDIMAS">BuyMeACoffee</a>.
The source code for this tutorial is available on <a href="https://github.com/mrDIMAS/rg3d-tutorials">GitHub</a>.</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/ois776/media_writing_a_roleplaying_game_using_rg3d_game/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h1>
<p>rusty-editor is a native <strong>scene</strong> editor for rg3d game engine. It offers wide variety of tools to make creation of
the scenes comfortable and intuitive.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>The editor has lots of windows with various purposes. Typical look of the editor could be something like this
(please note that it can change over time, because the development is quite rapid and image can become outdated
pretty easily):</p>
<p><img src="rusty-editor/./typical_look.png" alt="Typical look" /></p>
<p>Lets do a brief overview what window is responsible for what, there will be a separate chapter for each window.</p>
<p><img src="rusty-editor/./overview.png" alt="Windows" /></p>
<ol>
<li><strong>World viewer</strong> - shows every object in the scene and their relations. It allows you to inspect the contents
of the scene in structured form.</li>
<li><strong>Scene preview</strong> - renders your scene with debug info and various editor-specific objects (like gizmos and
stuff). Allows you to select, move, rotate, scale, delete, etc. various entities.</li>
<li><strong>Tool bar</strong> - shows available context-dependent tools.</li>
<li><strong>Inspector</strong> - allows you to modify various properties of selected object.</li>
<li><strong>Message log</strong> - shows the important messages from the editor.</li>
<li><strong>Navmesh panel</strong> - allows you to create/delete and edit navigational meshes.</li>
<li><strong>Command stack</strong> - shows the most recent actions you've done, allows you to undo and redo the changes on demand.</li>
<li><strong>Asset browser</strong> - inspects the assets of your game, allows you to instantiate resources in the scene and so on.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
