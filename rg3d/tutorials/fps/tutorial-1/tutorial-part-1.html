<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Character controller - rg3d Cheat Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../../favicon.svg">
        <link rel="shortcut icon" href="../../../../favicon.png">
        <link rel="stylesheet" href="../../../../css/variables.css">
        <link rel="stylesheet" href="../../../../css/general.css">
        <link rel="stylesheet" href="../../../../css/chrome.css">
        <link rel="stylesheet" href="../../../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../../highlight.css">
        <link rel="stylesheet" href="../../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/introduction.html"><strong aria-hidden="true">2.</strong> rg3d</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/beginning/getting_started.html"><strong aria-hidden="true">2.1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/beginning/framework.html"><strong aria-hidden="true">2.1.1.</strong> Framework</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/beginning/custom_game_loop.html"><strong aria-hidden="true">2.1.2.</strong> Custom game loop</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/beginning/scene_and_scene_graph.html"><strong aria-hidden="true">2.1.3.</strong> Scene and scene graph</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/beginning/data_management.html"><strong aria-hidden="true">2.1.4.</strong> Data management</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../rg3d/animation/animation.html"><strong aria-hidden="true">2.2.</strong> Animation</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/rendering/rendering.html"><strong aria-hidden="true">2.3.</strong> Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/rendering/shaders.html"><strong aria-hidden="true">2.3.1.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/rendering/materials.html"><strong aria-hidden="true">2.3.2.</strong> Materials</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../rg3d/sound/sound.html"><strong aria-hidden="true">2.4.</strong> Sound</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/physics/physics.html"><strong aria-hidden="true">2.5.</strong> Physics</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/ui/ui.html"><strong aria-hidden="true">2.6.</strong> User Interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/ui/setting_up.html"><strong aria-hidden="true">2.6.1.</strong> Setting up a user interface</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/ui/creating_button.html"><strong aria-hidden="true">2.6.2.</strong> Creating a button</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/ui/general_rules.html"><strong aria-hidden="true">2.6.3.</strong> General rules</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../rg3d/resources/resources.html"><strong aria-hidden="true">2.7.</strong> Resource Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/resources/model.html"><strong aria-hidden="true">2.7.1.</strong> 3D Models</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/resources/texture.html"><strong aria-hidden="true">2.7.2.</strong> Textures</a></li><li class="chapter-item expanded "><a href="../../../../.rg3d/resources/sound.html"><strong aria-hidden="true">2.7.3.</strong> Sound Buffers</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/tutorials.html"><strong aria-hidden="true">2.8.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/fps/intro.html"><strong aria-hidden="true">2.8.1.</strong> FPS Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html" class="active"><strong aria-hidden="true">2.8.1.1.</strong> Character controller</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html"><strong aria-hidden="true">2.8.1.2.</strong> Weapons</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/fps/tutorial-3/tutorial-part-3.html"><strong aria-hidden="true">2.8.1.3.</strong> Bots and AI</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/rpg/intro.html"><strong aria-hidden="true">2.8.2.</strong> RPG Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/rpg/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">2.8.2.1.</strong> Character controller</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../../rusty-editor/introduction.html"><strong aria-hidden="true">3.</strong> rusty-editor</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rg3d Cheat Book</h1>

                    <div class="right-buttons">
                        <a href="../../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><strong>Source code</strong>: <a href="https://github.com/rg3dengine/rg3d-tutorials/tree/main/tutorial1-character-controller">GitHub</a></p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#creating-a-window">Creating a window</a></li>
<li><a href="#creating-your-first-scene">Creating your first scene</a></li>
<li><a href="#using-the-scene">Using the scene</a></li>
<li><a href="#character-controller">Character controller</a></li>
<li><a href="#finishing-touch">Finishing touch</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>rg3d is a general purpose 3D engine, it allows creating any kind of 3D game, but today we'll focus on classic 3D shooter.
In this tutorial we'll write a simple character controller. This is what we're aiming for:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/VcN3NUdfg3E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Let's start by creating a new cargo project, make a folder and execute this:</p>
<pre><code class="language-bash">cargo init --bin
</code></pre>
<p>Open Cargo.toml and add <code>rg3d</code> dependency:</p>
<pre><code class="language-toml">[dependencies]
# Use specific version from GitHub, because engine changes rapidly and we must use specific version
# to make sure it compiles.
rg3d = { git = &quot;https://github.com/rg3dengine/rg3d&quot;, rev = &quot;a3c3d678c361aa72fc44c36f3e37adc20a54f311&quot; }
</code></pre>
<h3 id="creating-a-window"><a class="header" href="#creating-a-window">Creating a window</a></h3>
<p>Great! Now we can start writing the game. Let's start from something very simple - a window and a main loop. Just copy 
and paste this code in the <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use rg3d::{
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    engine::{
        resource_manager::{MaterialSearchOptions, ResourceManager},
        Engine,
    },
    event::{DeviceEvent, ElementState, Event, VirtualKeyCode, WindowEvent},
    event_loop::{ControlFlow, EventLoop},
    physics3d::{
        rapier::{dynamics::RigidBodyBuilder, geometry::ColliderBuilder},
        RigidBodyHandle,
    },
    resource::texture::TextureWrapMode,
    scene::{
        base::BaseBuilder,
        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
        node::Node,
        transform::TransformBuilder,
        Scene,
    },
    window::WindowBuilder,
};
use std::time;

// Our game logic will be updated at 60 Hz rate.
const TIMESTEP: f32 = 1.0 / 60.0;

struct Game {
    // Empty for now.
}

impl Game {
    pub fn new() -&gt; Self {
        Self {}
    }

    pub fn update(&amp;mut self) {
        // Game logic will be placed here.
    }
}

fn main() {
    // Configure main window first.
    let window_builder = WindowBuilder::new().with_title(&quot;3D Shooter Tutorial&quot;);
    // Create event loop that will be used to &quot;listen&quot; events from the OS.
    let event_loop = EventLoop::new();

    // Finally create an instance of the engine.
    let mut engine = Engine::new(window_builder, &amp;event_loop, false).unwrap();

    // Initialize game instance. It is empty for now.
    let mut game = Game::new();

    // Run the event loop of the main window. which will respond to OS and window events and update
    // engine's state accordingly. Engine lets you to decide which event should be handled,
    // this is a minimal working example of how it should be.
    let clock = time::Instant::now();

    let mut elapsed_time = 0.0;
    event_loop.run(move |event, _, control_flow| {
        match event {
            Event::MainEventsCleared =&gt; {
                // This main game loop - it has fixed time step which means that game
                // code will run at fixed speed even if renderer can't give you desired
                // 60 fps.
                let mut dt = clock.elapsed().as_secs_f32() - elapsed_time;
                while dt &gt;= TIMESTEP {
                    dt -= TIMESTEP;
                    elapsed_time += TIMESTEP;

                    // Run our game's logic.
                    game.update();

                    // Update engine each frame.
                    engine.update(TIMESTEP);
                }

                // Rendering must be explicitly requested and handled after RedrawRequested event is received.
                engine.get_window().request_redraw();
            }
            Event::RedrawRequested(_) =&gt; {
                // Render at max speed - it is not tied to the game code.
                engine.render().unwrap();
            }
            Event::WindowEvent { event, .. } =&gt; match event {
                WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
                WindowEvent::KeyboardInput { input, .. } =&gt; {
                    // Exit game by hitting Escape.
                    if let Some(VirtualKeyCode::Escape) = input.virtual_keycode {
                        *control_flow = ControlFlow::Exit
                    }
                }
			    WindowEvent::Resized(size) =&gt; {
                    // It is very important to handle Resized event from window, because
                    // renderer knows nothing about window size - it must be notified
                    // directly when window size has changed.
                    engine.set_frame_size(size.into()).unwrap();
                }
                _ =&gt; (),
            },
            _ =&gt; *control_flow = ControlFlow::Poll,
        }
    });
}
</code></pre></pre>
<p>Wow! There is lots of code for such a simple task. Fear not, everything here is pretty straightforward, let's dive into
this code and disassemble it line by line. Just skip imports, it's too boring. Let's look at this line:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const TIMESTEP: f32 = 1.0 / 60.0;
<span class="boring">}
</span></code></pre></pre>
<p>Here we define a rate of update for logic of our future game, just sticking to common 60 FPS. Next goes the skeleton of
the game, just a struct with two methods. It will be filled later in this tutorial.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    // Empty for now.
}

impl Game {
    pub fn new() -&gt; Self {
        Self {}
    }

    pub fn update(&amp;mut self) {
        // Game logic will be placed here.
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we at the point where the interesting stuff happens - <code>fn main()</code>. We're starting by creating a window builder:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let window_builder = WindowBuilder::new().with_title(&quot;3D Shooter Tutorial&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The builder will be used later by the engine to create a window. Next we're creating our event loop: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let event_loop = EventLoop::new();
<span class="boring">}
</span></code></pre></pre>
<p>The event loop is a &quot;magic&quot; thing that receives events from the operating system and feeds your application, this is a very 
important part which makes the application work. Finally, we're creating an instance of the engine:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new(window_builder, &amp;event_loop, false).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>The first two parameters are the window builder and the event loop, the last one is a boolean flag that is responsible for vertical
synchronization (VSync). In this tutorial we'll have VSync disabled, because it requires specific platform-dependent
extenstions which are not always available and callind <code>.unwrap()</code> might result in panic on some platforms. Next we're 
creating an instance of the game, remember this line, it will be changed soon:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut game = Game::new();
<span class="boring">}
</span></code></pre></pre>
<p>Next we define two variables for the game loop: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let clock = time::Instant::now();
let mut elapsed_time = 0.0;
<span class="boring">}
</span></code></pre></pre>
<p>At first, we &quot;remember&quot; the starting point of the game in time. The next variable is used to control the game loop. Finally, we run the
event loop and start checking for events coming from the OS:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>event_loop.run(move |event, _, control_flow| {
    match event {
        ...
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>Let's look at each event separately starting from <code>Event::MainEventsCleared</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::MainEventsCleared =&gt; {
    // This main game loop - it has fixed time step which means that game
    // code will run at fixed speed even if renderer can't give you desired
    // 60 fps.
    let mut dt = clock.elapsed().as_secs_f32() - elapsed_time;
    while dt &gt;= TIMESTEP {
        dt -= TIMESTEP;
        elapsed_time += TIMESTEP;

        // Run our game's logic.
        game.update();

        // Update engine each frame.
        engine.update(TIMESTEP);
    }

    // Rendering must be explicitly requested and handled after RedrawRequested event is received.
    engine.get_window().request_redraw();
}
<span class="boring">}
</span></code></pre></pre>
<p>This is the heart of game loop - it stabilizes update rate of game logic by measuring time from last update call
and performs a various amount of iterations based on an amount of time since last update. This makes the game logic update
rate independent of FPS - it will be always 60 Hz for game logic even if FPS is 10. The <code>while</code> loop contains 
<code>game.update()</code> and <code>engine.update(TIMESTEP)</code> calls to update game's logic and engine internals respectively. After the
loop we're asking the engine to render the next frame. In the next match arm <code>Event::RedrawRequested</code> we're handing our request: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::RedrawRequested(_) =&gt; {
    // Render at max speed - it is not tied to the game code.
    engine.render().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see rendering happens in a single line of code. Next we need to handle window events:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::WindowEvent { event, .. } =&gt; match event {
    WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
    WindowEvent::KeyboardInput { input, .. } =&gt; {
        // Exit game by hitting Escape.
        if let Some(VirtualKeyCode::Escape) = input.virtual_keycode {
            *control_flow = ControlFlow::Exit
        }
    }
	WindowEvent::Resized(size) =&gt; {
		// It is very important to handle Resized event from window, because
		// renderer knows nothing about window size - it must be notified
		// directly when window size has changed.
		engine.set_frame_size(size.into()).unwrap();
	}
    _ =&gt; (),
},
<span class="boring">}
</span></code></pre></pre>
<p>Here we're just checking if the player has hit Escape button and exit game if so. Also, when <code>WindowEvent::Resized</code> is 
received, we're notifying renderer about that, so it's render targets will be resized too. The final match arm is for 
every other event, nothing fancy here - just asking engine to continue listening for new events.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>_ =&gt; *control_flow = ControlFlow::Poll,
<span class="boring">}
</span></code></pre></pre>
<p>So far so good. This small piece of code just creates a new window and fills it with black color, now we can start 
writing the game. </p>
<p><img src="./tutorial1-window.jpg" alt="Window" /></p>
<p>Let's start by creating a simple scene where we'll test our character controller. This is the time when 
<a href="https://github.com/mrDIMAS/rusty-editor">rusty-editor</a> comes into play - rusty-editor is a native scene editor of the
engine. It is worth mentioning what &quot;scene editor&quot; means: unlike many other engines (Unity, UnrealEngine, etc.),
rusty-editor does <strong>not</strong> allow you to run your game inside it, instead you just edit your scene, save it in the editor and load it in
your game. Being able to run a game inside the editor was a very huge task for one person, and I just chose the 
easiest way. Alright, back to the interesting stuff. Build the editor first using instructions from its
<a href="https://github.com/mrDIMAS/rusty-editor">GitHub page</a> using specific commit stated in the beginning of the article.</p>
<h2 id="creating-your-first-scene"><a class="header" href="#creating-your-first-scene">Creating your first scene</a></h2>
<p>This section is completely optional, if you eager to make the game - just use a 
<a href="./data.zip">pre-made scene</a> (download it and unpack in the folder of your game) and go to
the <a href="#using-the-scene">next section</a>. Open rusty-editor, it should look like this:</p>
<p><img src="./tutorial1-rusty-editor.jpg" alt="rusty-editor" /></p>
<p>It will ask you to choose a working directory.</p>
<p><img src="./tutorial1-configurator.jpg" alt="configurator" /></p>
<p>The working directory is simply a path to your game's executable, in most cases it will be the root folder of your
project.</p>
<p>Next, click <code>File -&gt; CreateScene</code>. Now you can start modifying your scene. All we need for now is a floor and maybe 
some decorations. To do that, you can either create everything from simple objects (cubes, cones, cylinders,
etc.) or load some assets made in 3D editors (like Blender, 3Ds max, etc.). Here we combine two approaches: floor will 
be just a squashed cube and decorations will be 3D models. Let's start from the floor. Click <code>Create -&gt; Mesh -&gt; Cube</code>, 
select the cube and use Scale tool from the toolbar to squash it to form the floor.</p>
<p><img src="./tutorial1-rusty-editor-floor.jpg" alt="Floor" /></p>
<p>Next we need to add physical body to the floor to not fall through it. This is very simple, click <code>Create -&gt; Physics -&gt; Rigid Body</code>
then right-click on the rigid body in the World Viewer and click <code>Add Trimesh Collider</code>. The last step is to bind the 
floor 3D model with the rigid body, to do that drag'n'drop the rigid body on the floor entry in the World Viewer.</p>
<p><img src="./tutorial1-rusty-editor-floor-body.jpg" alt="Floor Body" /></p>
<p>Ok, good, but it looks awful, let's add some texture to it, to do that, 
<a href="./floor.jpg">download floor texture</a>, place it to <code>data/textures</code> and apply it to the floor. 
To do that, use the asset browser: at its left side it shows file system of your project, locate <code>data/textures</code> folder 
and select <code>floor.jpg</code>. Now just drag-n-drop the texture to the floor, this is what you should get.</p>
<p><img src="./tutorial1-rusty-editor-floor-texture.jpg" alt="Floor Texture" /></p>
<p>Now let's add some decorations, to do that <a href="./barrel.zip">download 3D model</a> I prepared for
this tutorial and unpack it in <code>data/models</code>. Now go to the <code>data/models</code> in the asset browser and just drag-n-drop the
<code>barrel.FBX</code> to the scene. When you'll release the mouse button after dragging, the editor will ask you where to search 
textures for your model, leave everything as is and click &quot;ok&quot;. You can find more info about import options 
<a href="https://docs.rs/rg3d/0.23.1/rg3d/engine/resource_manager/enum.MaterialSearchOptions.html">here</a>. Now use the Scale and 
Move tools to adjust scale and position of the barrel, it should look like this: </p>
<p><img src="./tutorial1-rusty-editor-barrel.jpg" alt="Barrel" /></p>
<p>Barrel does not have any rigid body yet, and it won't interact with world. Let's fix this. As usual, click <code>Create -&gt; Physics -&gt; Rigid Body</code> 
then click on the added rigid body and add a cylinder collider by right-click on it and selecting <code>Add Cylinder Collider</code>.
Now select the collider and adjust its height and radius. As a final step drag'n'drop the body on the <code>barrel.FBX</code> scene 
node. Keep in mind that every physical body <strong>must</strong> be assigned to &quot;root&quot; node of an object, in case of barrel it will
be <code>barrel.FBX</code> node. Why so? Physical bodies operate in <strong>global</strong> coordinates, and if you'll assign a body to a child node,
rg3d will apply global coordinates of the body as <strong>local</strong> coordinates of the child node. This will result in a desync of
coordinates of the body and the node. This a common mistake made by editor's users.</p>
<p><img src="./tutorial1-rusty-editor-barrel-body.jpg" alt="Barrel Body" /></p>
<p>Now clone some barrels, to do that select a <code>barrel.FBX</code> in the <code>World Outliner</code>, right-click on the scene preview and
press <code>Ctrl+C</code> to copy the barrel and <code>Ctrl+V</code> to paste. Repeat multiple times.</p>
<p><img src="./tutorial1-rusty-editor-barrels.jpg" alt="Barrel" /></p>
<p>Also add a light source, to do that go to <code>Create -&gt; Light -&gt; Point</code> and adjust its position using the Move tool.</p>
<p><img src="./tutorial1-rusty-editor-light.jpg" alt="Barrel" /></p>
<p>The final step: save your scene in <code>data/models</code>, to do that go to <code>File -&gt; Save</code> and select the folder and type name 
of the scene in the field it should be <code>scene.rgs</code>.</p>
<h2 id="using-the-scene"><a class="header" href="#using-the-scene">Using the scene</a></h2>
<p>Now it's the time to load the scene we've made earlier in the game. This is very simple, all we need to do is to load
scene as resource and create its instance. Change <code>fn new()</code> body to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn new(engine: &amp;mut GameEngine) -&gt; Self {
    let mut scene = Scene::new();

    // Load a scene resource and create its instance.
    engine
        .resource_manager
        .request_model(&quot;data/models/scene.rgs&quot;, MaterialSearchOptions::UsePathDirectly)
        .await
        .unwrap()
        .instantiate_geometry(&amp;mut scene);

    // Next create a camera, it is our &quot;eyes&quot; in the world.
    // This can also be made in editor, but for educational purpose we'll made it by hand.
    let camera = CameraBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, 1.0, -3.0))
                .build(),
        ),
    )
    .build(&amp;mut scene.graph);

    Self {
        camera,
        scene: engine.scenes.add(scene),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You may have noticed that the <code>Game</code> structure now has two new fields: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;, // A handle to the scene
    camera: Handle&lt;Node&gt;, // A handle to the camera
}
<span class="boring">}
</span></code></pre></pre>
<p>These fields are just handles to the &quot;entities&quot; we've created in the <code>Game::new()</code>. Also, change <code>let mut game = Game::new();</code> to this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut game = rg3d::core::futures::executor::block_on(Game::new(&amp;mut engine));
<span class="boring">}
</span></code></pre></pre>
<p>Here we execute async function <code>Game::new()</code> and it creates game's instance with the scene we've made previously.
Run the game and you should see this:</p>
<p><img src="./tutorial1-scene.jpg" alt="Barrel" /></p>
<p>Cool! Now let's disassemble <code>fn new()</code> line by line. First, we're creating an empty scene:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut scene = Scene::new();
<span class="boring">}
</span></code></pre></pre>
<p>The next few lines are the most interesting:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine
    .resource_manager
    .request_model(&quot;data/models/scene.rgs&quot;, MaterialSearchOptions::UsePathDirectly)
    .await
    .unwrap()
    .instantiate_geometry(&amp;mut scene);
<span class="boring">}
</span></code></pre></pre>
<p>Here we're asking the resource manager to load the scene we've made previously, awaiting while it loads and then instantiating
it on the <code>scene</code>. What does &quot;instantiation&quot; mean? In short, it means that we're creating a copy of a scene and adding the copy
to some other scene, the engine remembers connections between clones and original entities and is capable of restoring data
from resource for the instance. At this point we've successfully instantiated the scene. However, we won't see anything
yet - we need a camera:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = CameraBuilder::new(
    BaseBuilder::new().with_local_transform(
        TransformBuilder::new()
            .with_local_position(Vector3::new(0.0, 1.0, -3.0))
            .build(),
    ),
)
.build(&amp;mut scene.graph);
<span class="boring">}
</span></code></pre></pre>
<p>Camera is our &quot;eyes&quot; in the world, here we're just creating a camera and moving it a bit up and back to be able to see the 
scene. Finally, we're adding the scene to the engine's container for scenes, and it gives us a handle to the scene. Later
we'll use the handle to borrow scene and modify it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    camera,
    scene: engine.scenes.add(scene),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="character-controller"><a class="header" href="#character-controller">Character controller</a></h2>
<p>We've made a lot of things already, but still can't move in the scene. Let's fix this! We'll start writing the character
controller which will allow us to walk in our scene. Let's start with a chunk of code as usual:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct InputController {
    move_forward: bool,
    move_backward: bool,
    move_left: bool,
    move_right: bool,
    pitch: f32,
    yaw: f32,
}

struct Player {
    pivot: Handle&lt;Node&gt;,
    camera: Handle&lt;Node&gt;,
    rigid_body: RigidBodyHandle,
    controller: InputController,
}

impl Player {
    fn new(scene: &amp;mut Scene) -&gt; Self {
        // Create a pivot and attach a camera to it, move it a bit up to &quot;emulate&quot; head.
        let camera;
        let pivot = BaseBuilder::new()
            .with_children(&amp;[{
                camera = CameraBuilder::new(
                    BaseBuilder::new().with_local_transform(
                        TransformBuilder::new()
                            .with_local_position(Vector3::new(0.0, 0.25, 0.0))
                            .build(),
                    ),
                )
                .build(&amp;mut scene.graph);
                camera
            }])
            .build(&amp;mut scene.graph);

        // Create rigid body, it will be used for interaction with the world.
        let rigid_body_handle = scene.physics.add_body(
            RigidBodyBuilder::new_dynamic()
                .lock_rotations() // We don't want the player to tilt.
                .translation(Vector3::new(0.0, 1.0, -1.0)) // Offset player a bit.
                .build(),
        );

        // Add capsule collider for the rigid body.
        scene.physics.add_collider(
            ColliderBuilder::capsule_y(0.25, 0.2).build(),
            &amp;rigid_body_handle,
        );

        // Bind pivot with rigid body. Scene will automatically sync transform of the pivot
        // with the transform of the rigid body.
        scene.physics_binder.bind(pivot, rigid_body_handle);

        Self {
            pivot,
            camera,
            rigid_body: rigid_body_handle.into(),
            controller: Default::default(),
        }
    }

    fn update(&amp;mut self, scene: &amp;mut Scene) {
        // Set pitch for the camera. These lines responsible for up-down camera rotation.
        scene.graph[self.camera].local_transform_mut().set_rotation(
            UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.controller.pitch.to_radians()),
        );

        // Borrow the pivot from the graph.
        let pivot = &amp;mut scene.graph[self.pivot];

        // Borrow rigid body from physics.
        let body = scene
            .physics
            .bodies
            .get_mut(&amp;self.rigid_body)
            .unwrap();

        // Keep only vertical velocity, and drop horizontal.
        let mut velocity = Vector3::new(0.0, body.linvel().y, 0.0);

        // Change the velocity depending on the keys pressed.
        if self.controller.move_forward {
            // If we moving forward then add &quot;look&quot; vector of the pivot.
            velocity += pivot.look_vector();
        }
        if self.controller.move_backward {
            // If we moving backward then subtract &quot;look&quot; vector of the pivot.
            velocity -= pivot.look_vector();
        }
        if self.controller.move_left {
            // If we moving left then add &quot;side&quot; vector of the pivot.
            velocity += pivot.side_vector();
        }
        if self.controller.move_right {
            // If we moving right then subtract &quot;side&quot; vector of the pivot.
            velocity -= pivot.side_vector();
        }

        // Finally new linear velocity.
        body.set_linvel(velocity, true);

        // Change the rotation of the rigid body according to current yaw. These lines responsible for
        // left-right rotation.
        let mut position = *body.position();
        position.rotation =
            UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), self.controller.yaw.to_radians());
        body.set_position(position, true);
    }

    fn process_input_event(&amp;mut self, event: &amp;Event&lt;()&gt;) {
        match event {
            Event::WindowEvent { event, .. } =&gt; {
                if let WindowEvent::KeyboardInput { input, .. } = event {
                    if let Some(key_code) = input.virtual_keycode {
                        match key_code {
                            VirtualKeyCode::W =&gt; {
                                self.controller.move_forward = input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::S =&gt; {
                                self.controller.move_backward =
                                    input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::A =&gt; {
                                self.controller.move_left = input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::D =&gt; {
                                self.controller.move_right = input.state == ElementState::Pressed;
                            }
                            _ =&gt; (),
                        }
                    }
                }
            }
            Event::DeviceEvent { event, .. } =&gt; {
                if let DeviceEvent::MouseMotion { delta } = event {
                    self.controller.yaw -= delta.0 as f32;

                    self.controller.pitch =
                        (self.controller.pitch + delta.1 as f32).clamp(-90.0, 90.0);
                }
            }
            _ =&gt; (),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is all the code we need for character controller, quite a lot actually, but as usual everything here is pretty
straightforward.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Also we must change Game structure a bit too and the new() code.
struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player, // New
}

impl Game {
    pub async fn new(engine: &amp;mut GameEngine) -&gt; Self {
        let mut scene = Scene::new();

        // Load a scene resource and create its instance.
        engine
            .resource_manager
            .request_model(&quot;data/models/scene.rgs&quot;, MaterialSearchOptions::UsePathDirectly)
            .await
            .unwrap()
            .instantiate_geometry(&amp;mut scene);

        Self {
            player: Player::new(&amp;mut scene), // New
            scene: engine.scenes.add(scene),
        }
    }

    pub fn update(&amp;mut self, engine: &amp;mut Engine) {
        self.player.update(&amp;mut engine.scenes[self.scene]); // New
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We've moved camera creation to <code>Player</code>, because now the camera is attached to the player's body. Also, we must add this line
in the beginning of <code>event_loop.run(...)</code> to let <code>player</code> handle input events:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>game.player.process_input_event(&amp;event);        
<span class="boring">}
</span></code></pre></pre>
<p>So, let's try to understand what happens in this huge chunk of code. Let's start from the <code>InputController</code> struct,
it holds the state of the input for a single frame and rotations of player &quot;parts&quot;. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct InputController {
    move_forward: bool,
    move_backward: bool,
    move_left: bool,
    move_right: bool,
    pitch: f32,
    yaw: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Next goes the <code>Player::new()</code> function. First, we're creating a simple chain of nodes of different kinds in the
<a href="https://en.wikipedia.org/wiki/Scene_graph">scene graph</a>. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera;
let pivot = BaseBuilder::new()
    .with_children(&amp;[{
        camera = CameraBuilder::new(
            BaseBuilder::new().with_local_transform(
                TransformBuilder::new()
                    .with_local_position(Vector3::new(0.0, 0.25, 0.0))
                    .build(),
            ),
        )
        .build(&amp;mut scene.graph);
        camera
    }])
    .build(&amp;mut scene.graph);
<span class="boring">}
</span></code></pre></pre>
<p>Basically we're making something like this:</p>
<p><img src="./tutorial1-graph-example.png" alt="Graph" /></p>
<p>As you can see, the camera is attached to the pivot and has a <strong>relative</strong> position of <code>(0.0, 0.25, 0.0)</code>. So when we'll
move pivot, the camera will move too (and rotate of course). Next we're adding a rigid body with a capsule collider and
link it with the pivot.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create rigid body, it will be used for interaction with the world.
let rigid_body_handle = scene.physics.add_body(
    RigidBodyBuilder::new_dynamic()
        .lock_rotations() // We don't want the player to tilt.
        .translation(Vector3::new(0.0, 1.0, -1.0)) // Offset player a bit.
        .build(),
);

// Add capsule collider for the rigid body.
scene.physics.add_collider(
    ColliderBuilder::capsule_y(0.25, 0.2).build(),
    rigid_body_handle,
);

// Bind pivot with rigid body. Scene will automatically sync transform of the pivot
// with the transform of the rigid body.
scene.physics_binder.bind(pivot, rigid_body_handle);
<span class="boring">}
</span></code></pre></pre>
<p>Comments should clarify what is going on here. Finally, we're creating Player instance and return it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    pivot,
    camera,
    rigid_body: rigid_body_handle.into(),
    controller: Default::default(),
}
<span class="boring">}
</span></code></pre></pre>
<p>Next goes the <code>fn update(...)</code> function, it is responsible for movement of the player. It starts from these lines:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set pitch for the camera. These lines responsible for up-down camera rotation.
scene.graph[self.camera].local_transform_mut().set_rotation(
    UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.controller.pitch.to_radians()),
);
<span class="boring">}
</span></code></pre></pre>
<p>We're borrowing the camera from the graph (<code>scene.graph[self.camera]</code>) and modifying its <strong>local</strong> rotation, using a 
<a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">quaternion</a> built from an axis, and an angle.
This rotates camera in vertical direction. Let's talk about borrowing in the engine. Almost every object in the 
engine &quot;lives&quot; in generational arenas (pool in rg3d's terminology). Pool is a contiguous chunk of memory, to be
able to &quot;reference&quot; an object in a pool rg3d uses handles. Almost every entity has a single owner - the engine,
so to mutate or read data from an entity your have to borrow it first, like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Borrow the pivot from the graph.
let pivot = &amp;mut scene.graph[self.pivot];

// Borrow rigid body from physics.
let body = scene
    .physics
    .bodies
    .get_mut(self.rigid_body.into())
    .unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>This piece of code <code>scene.graph[self.pivot]</code> borrows <code>pivot</code> as either mutable or shared, depending on the context (basically
it is just an implementation of Index + IndexMut traits). Once we've borrowed objects, we can modify them. As the next
step we calculate new horizontal speed for the player:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Keep only vertical velocity, and drop horizontal.
let mut velocity = Vector3::new(0.0, body.linvel().y, 0.0);

// Change the velocity depending on the keys pressed.
if self.controller.move_forward {
    // If we moving forward then add &quot;look&quot; vector of the pivot.
    velocity += pivot.look_vector();
}
if self.controller.move_backward {
    // If we moving backward then subtract &quot;look&quot; vector of the pivot.
    velocity -= pivot.look_vector();
}
if self.controller.move_left {
    // If we moving left then add &quot;side&quot; vector of the pivot.
    velocity += pivot.side_vector();
}
if self.controller.move_right {
    // If we moving right then subtract &quot;side&quot; vector of the pivot.
    velocity -= pivot.side_vector();
}

// Finally new linear velocity.
body.set_linvel(velocity, true);
<span class="boring">}
</span></code></pre></pre>
<p>We don't need to modify vertical speed, because it should be controlled by the physics engine. Finally, we're setting
rotation of the rigid body:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Change the rotation of the rigid body according to current yaw. These lines responsible for
// left-right rotation.
let mut position = *body.position();
position.rotation = UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), self.controller.yaw.to_radians());
body.set_position(position, true);
<span class="boring">}
</span></code></pre></pre>
<p>The next piece of code is a bit boring, but still should be addressed - it is input handling. In the <code>process_input_event</code>
we check input events and configure input controller accordingly. Basically we're just checking if W, S, A, D keys were 
pressed or released. In the <code>MouseMotion</code> arm, we're modifying yaw and pitch of the controller according to mouse 
velocity. Nothing fancy, except this line:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.controller.pitch = (self.controller.pitch + delta.1 as f32).clamp(-90.0, 90.0);
<span class="boring">}
</span></code></pre></pre>
<p>Here we're just restricting pitch to [-90; 90] degree range to not let flipping camera upside-down. Now let's run the 
game, you should see something like this and be able to walk and turn the camera.</p>
<p><img src="./tutorial1-controller.jpg" alt="Controller" /></p>
<h2 id="finishing-touch"><a class="header" href="#finishing-touch">Finishing touch</a></h2>
<p>One more thing before we end the tutorial. Black &quot;void&quot; around us isn't nice, let's add skybox for the camera to improve
that. Skybox is a very simple effect that significantly improves scene quality. To add a skybox, add this code first
somewhere before <code>impl Player</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn create_skybox(resource_manager: ResourceManager) -&gt; SkyBox {
    // Load skybox textures in parallel.
    let (front, back, left, right, top, bottom) = rg3d::core::futures::join!(
        resource_manager.request_texture(&quot;data/textures/skybox/front.jpg&quot;, None),
        resource_manager.request_texture(&quot;data/textures/skybox/back.jpg&quot;, None),
        resource_manager.request_texture(&quot;data/textures/skybox/left.jpg&quot;, None),
        resource_manager.request_texture(&quot;data/textures/skybox/right.jpg&quot;, None),
        resource_manager.request_texture(&quot;data/textures/skybox/up.jpg&quot;, None),
        resource_manager.request_texture(&quot;data/textures/skybox/down.jpg&quot;, None)
    );

    // Unwrap everything.
    let skybox = SkyBoxBuilder {
        front: Some(front.unwrap()),
        back: Some(back.unwrap()),
        left: Some(left.unwrap()),
        right: Some(right.unwrap()),
        top: Some(top.unwrap()),
        bottom: Some(bottom.unwrap()),
    }
        .build()
        .unwrap();

    // Set S and T coordinate wrap mode, ClampToEdge will remove any possible seams on edges
    // of the skybox.
    let skybox_texture = skybox.cubemap().unwrap();
    let mut data = skybox_texture.data_ref();
    data.set_s_wrap_mode(TextureWrapMode::ClampToEdge);
    data.set_t_wrap_mode(TextureWrapMode::ClampToEdge);

    skybox
}
<span class="boring">}
</span></code></pre></pre>
<p>Then modify signature of <code>Player::new</code> to </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn new(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Self
<span class="boring">}
</span></code></pre></pre>
<p>We just added resource manager parameter here, and made the function async, because we'll load a bunch of textures 
in the <code>create_skybox</code> function. Add following line at camera builder (before <code>.build</code>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_skybox(create_skybox(resource_manager).await)
<span class="boring">}
</span></code></pre></pre>
<p>Also modify player creation in <code>Game::new</code> to this</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>player: Player::new(&amp;mut scene, engine.resource_manager.clone()).await,
<span class="boring">}
</span></code></pre></pre>
<p>Next, download skybox textures from <a href="./skybox.zip">here</a> and extract the archive in 
<code>data/textures</code> (all textures from  the archive must be in <code>data/textures/skybox</code>). Now you can run the game, and you
should see something like this:</p>
<p><img src="./tutorial1-skybox.jpg" alt="Controller" /></p>
<p>This was the last step of this tutorial.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this tutorial we've learned how to use the engine and the editor. Created simple character controller and walked on
the scene we've made in the editor. I hope you liked this tutorial, and if so, please consider supporting the project on 
<a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is available on
<a href="https://github.com/mrDIMAS/rg3d-tutorials">GitHub</a>. In the next tutorial we'll start adding weapons.</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/lyj1tq/writing_a_3d_shooter_using_rg3d_game_engine_1/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../../rg3d/tutorials/fps/intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../../../rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../../rg3d/tutorials/fps/intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../../../rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
